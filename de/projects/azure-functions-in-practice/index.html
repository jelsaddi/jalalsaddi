<!doctype html>
<html data-n-head-ssr>
  <head >
    <meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width, initial-scale=1"><meta data-n-head="ssr" data-hid="description" name="description" content=""><title>Azure Functions in der Praxis: Automatische Bildverarbeitung im E-Commerce</title><base href="/jalalsaddi/"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="favicon.ico"><link data-n-head="ssr" rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:100,200,300,400,500,600,700,800,900"><link data-n-head="ssr" rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i,800,800i"><link data-n-head="ssr" rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/simple-line-icons/2.4.1/css/simple-line-icons.css"><link data-n-head="ssr" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/konpa/devicon@df6431e323547add1b4cf45992913f15286456d3/devicon.min.css"><link data-n-head="ssr" rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous"><link data-n-head="ssr" rel="stylesheet" type="text/css" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous"><script data-n-head="ssr" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.1/js/solid.min.js"></script><script data-n-head="ssr" src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script><script data-n-head="ssr" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"></script><script data-n-head="ssr" src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script><link rel="preload" href="/jalalsaddi/_nuxt/d6a13ab.js" as="script"><link rel="preload" href="/jalalsaddi/_nuxt/e2f0863.js" as="script"><link rel="preload" href="/jalalsaddi/_nuxt/9478d7b.js" as="script"><link rel="preload" href="/jalalsaddi/_nuxt/2b0dd4f.js" as="script"><link rel="preload" href="/jalalsaddi/_nuxt/51f5aa4.js" as="script"><style data-vue-ssr-id="629c04aa:0 ff988300:0 306ea3c9:0 f88a5a40:0 2bef1f10:0 82aee578:0 516e6a4e:0">body{font-family:"Open Sans",serif;margin:0;padding:0}body,h1,h2,h3,h4,h5,h6{color:#343a40;color:var(--color-text-primary)}h1,h2,h3,h4,h5,h6{font-family:"Saira Extra Condensed",serif;font-weight:700;text-transform:uppercase}h1{font-size:6rem;line-height:5.5rem}h2{font-size:3.5rem}.subheading{font-family:"Saira Extra Condensed",serif;font-size:1.35rem;font-weight:500;text-transform:uppercase}.list-social-icons a{color:#7b5fc0;color:var(--color-primary)}.list-social-icons a:hover{color:#5e3d85;color:var(--color-primary-hover)}.list-social-icons a .fa-lg{font-size:1.75rem}.list-icons{font-size:3rem}.list-icons .list-inline-item i:hover{color:#5e3d85;color:var(--color-primary-hover)}#sideNav .navbar-nav .nav-item .nav-link{font-weight:600;text-transform:uppercase}@media (min-width:992px){#sideNav{display:flex;flex-direction:column;height:100vh;left:0;position:fixed;text-align:center;top:0;width:17rem}#sideNav .navbar-brand{display:flex;margin:auto auto 0;padding:.5rem}#sideNav .navbar-brand .img-profile{border:.5rem solid hsla(0,0%,100%,.2);max-height:10rem;max-width:10rem}#sideNav .navbar-collapse{align-items:flex-start;display:flex;flex-grow:0;margin-bottom:auto;width:100%}#sideNav .navbar-collapse .navbar-nav{flex-direction:column;width:100%}#sideNav .navbar-collapse .navbar-nav .nav-item,#sideNav .navbar-collapse .navbar-nav .nav-item .nav-link{display:block}}section.resume-section{border-bottom:1px solid #868e96;border-bottom:1px solid var(--color);padding-bottom:5rem!important;padding-top:5rem!important}section.resume-section .resume-item .resume-date{min-width:none}@media (min-width:768px){section.resume-section{min-height:100vh}section.resume-section .resume-item .resume-date{min-width:18rem}}@media (min-width:992px){section.resume-section{padding-bottom:3rem!important;padding-top:3rem!important}}.bg-primary{background-color:#7b5fc0!important;background-color:var(--color-primary)!important}.text-primary{color:#6a4ca0!important;color:var(--color-secondary)!important}a{color:#6a4ca0;color:var(--color-secondary)}a:active,a:focus,a:hover{color:#5e3d85;color:var(--color-primary-hover)}.vue-typer .custom.char{color:#343a40;color:var(--color-text-primary)}.card-body,.card-title{color:#868e96}:root{--color:#868e96;--color-primary:#7b5fc0;--color-secondary:#6a4ca0;--color-primary-hover:#5e3d85;--color-text-primary:#343a40;--color-text-secondary:#e2e2e2;--color-text-third:#343a40;--bg:#f3f5f4;--bg-secondary:#fff;--border-color:#ddd}.dark-mode{--color:#ebf4f1;--color-primary:#0a0d0f;--color-secondary:#000;--color-primary-hover:#020405;--color-text-primary:#fff;--color-text-secondary:#e2e2e2;--bg:#081927;--bg-secondary:#071521;--border-color:#0d2538}body{background-color:#f3f5f4;background-color:var(--bg);color:#868e96;color:var(--color);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Open Sans","Helvetica Neue",sans-seriff;transition:background-color .3s}a{color:#7b5fc0;color:var(--color-primary)}
.nuxt-progress{background-color:#3b8070;height:2px;left:0;opacity:1;position:fixed;right:0;top:0;transition:width .1s,opacity .4s;width:0;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}
.blog-layout{display:flex;flex-direction:column;min-height:100vh}.main-content{display:flex;flex:1;flex-direction:column}.content{flex:1}
.blog-header[data-v-39f68977]{background:inherit;position:sticky;text-align:center;top:0;z-index:1000}.blog-header-title[data-v-39f68977]{color:#fff;font-family:"Pacifico",cursive,"Saira Extra Condensed",serif;font-size:2rem;font-weight:700;letter-spacing:1px;margin:0;text-shadow:0 2px 8px rgba(0,0,0,.12)}.back-resume-btn[data-v-39f68977]{background:hsla(0,0%,100%,.1);border-radius:.25rem;color:#fff;font-size:.85rem;font-weight:600;padding:.3rem .75rem;position:absolute;right:1.5rem;-webkit-text-decoration:none;text-decoration:none;top:50%;transform:translateY(-50%);transition:background .2s}.back-resume-btn[data-v-39f68977]:hover{background:hsla(0,0%,100%,.25)}@media (max-width:767px){.blog-header[data-v-39f68977]{padding:1.2rem 1rem 1rem}.blog-header-title[data-v-39f68977]{font-size:1.3rem;margin-bottom:.5rem}.back-resume-btn[data-v-39f68977]{background:hsla(0,0%,100%,.15);display:inline-block;font-size:.9rem;margin-top:.5rem;position:static;transform:none}}
.breadcrumb-container[data-v-6d559f88]{margin:.5rem 1rem}.breadcrumb[data-v-6d559f88]{background:none;display:flex;flex-wrap:nowrap;list-style:none;margin:0;padding:0;white-space:nowrap}.breadcrumb-item+.breadcrumb-item[data-v-6d559f88]:before{color:#666;content:">";padding:0 .5rem}.breadcrumb-item a[data-v-6d559f88]{color:var(--color-primary);-webkit-text-decoration:none;text-decoration:none}.breadcrumb-item.active[data-v-6d559f88]{color:#999}@media (max-width:767px){.breadcrumb-container[data-v-6d559f88]{font-size:.85rem;padding:.5rem .75rem}.breadcrumb-item+.breadcrumb-item[data-v-6d559f88]:before{padding:0 .25rem}.breadcrumb[data-v-6d559f88]{font-size:.85rem}.breadcrumb-item a[data-v-6d559f88],.breadcrumb-item span[data-v-6d559f88]{display:inline-block;max-width:120px;overflow:hidden;text-overflow:ellipsis;vertical-align:middle;white-space:nowrap}}
.project-title[data-v-42ccd3fa]{font-size:2rem;font-weight:600;line-height:1.3;margin-bottom:2rem;text-align:center}
.text-layout[data-v-8732a564]{color:#2d2d2d;font-size:1.05rem;line-height:1.7;margin:0 auto;max-width:850px}.text-section[data-v-8732a564]{border-bottom:1px solid #eaeaea;margin-bottom:2.2rem;padding-bottom:1.2rem}.section-title[data-v-8732a564]{color:#7b5fc0;font-size:1.5rem;font-weight:600;margin-bottom:.8rem}.section-content[data-v-8732a564]{margin:.5rem 0;text-align:justify}.section-bullets[data-v-8732a564]{list-style-type:disc;margin-left:1.5rem;margin-top:.5rem}.section-bullets li[data-v-8732a564]{margin-bottom:.4rem}.section-code[data-v-8732a564]{background:hsla(0,0%,50%,.31);border-radius:.25rem;font-family:monospace;font-size:.95rem;margin:1rem 0;overflow-x:auto;padding:1rem}table[data-v-8732a564]{border-collapse:collapse;width:100%}td[data-v-8732a564],th[data-v-8732a564]{text-align:left}tr[data-v-8732a564]:hover{background-color:#f9f9ff}.inline-code[data-v-8732a564]{background:#eee;border-radius:.2rem;font-family:monospace;font-size:.95rem;padding:.1rem .3rem}.dark-mode .section-bullets li[data-v-8732a564],.dark-mode .section-content[data-v-8732a564],.dark-mode .section-title[data-v-8732a564],.dark-mode .text-layout[data-v-8732a564]{color:#fff!important}.dark-mode .section-code[data-v-8732a564]{background:#333;color:#fff}.dark-mode table tr[data-v-8732a564]:hover{background-color:#444}</style><link rel="preload" href="/jalalsaddi/_nuxt/static/1761557710/de/projects/azure-functions-in-practice/state.js" as="script"><link rel="preload" href="/jalalsaddi/_nuxt/static/1761557710/de/projects/azure-functions-in-practice/payload.js" as="script"><link rel="preload" href="/jalalsaddi/_nuxt/static/1761557710/manifest.js" as="script">
  </head>
  <body >
    <script data-n-head="ssr" data-hid="nuxt-color-mode-script" data-pbody="true">!function(){"use strict";var e=window,s=document,t=s.documentElement,n=["dark","light"],o=function(e){for(var t=e+"=",n=s.cookie.split(";"),o=0;o<n.length;o++){for(var a=n[o];" "===a.charAt(0);)a=a.substring(1,a.length);if(0===a.indexOf(t))return a.substring(t.length,a.length)}return null}("nuxt-color-mode")||"system",a="system"===o?c():o;function i(e){var s=""+e+"-mode";t.classList?t.classList.add(s):t.className+=" "+s}function r(s){return e.matchMedia("(prefers-color-scheme"+s+")")}function c(){if(e.matchMedia&&"not all"!==r("").media)for(var s of n)if(r(":"+s).matches)return s;return"light"}i(a),e["__NUXT_COLOR_MODE__"]={preference:o,value:a,getColorScheme:c,addClass:i,removeClass:function(e){var s=""+e+"-mode";t.classList?t.classList.remove(s):t.className=t.className.replace(new RegExp(s,"g"),"")}}}();
</script><div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="blog-layout"><header class="blog-header bg-primary text-white" data-v-39f68977><h1 class="blog-header-title" data-v-39f68977>Blog &amp; Projects</h1> <a href="/jalalsaddi/de/" class="back-resume-btn nuxt-link-active" data-v-39f68977>
    Zurück zum Lebenslauf
  </a></header> <nav aria-label="breadcrumb" class="breadcrumb-container" data-v-6d559f88><ol class="breadcrumb" data-v-6d559f88><li class="breadcrumb-item" data-v-6d559f88><a href="/jalalsaddi/" class="nuxt-link-active" data-v-6d559f88>
        Home
      </a></li><li class="breadcrumb-item" data-v-6d559f88><a href="/jalalsaddi/blog" data-v-6d559f88>
        Blog
      </a></li><li class="breadcrumb-item active" data-v-6d559f88><span data-v-6d559f88>Azure Functions in der Praxis: Automatische Bildverarbeitung im E-Commerce</span></li></ol></nav> <main class="main-content"><div class="container content"><main class="container flex-grow-1" style="padding-top:8rem;padding-bottom:5.5rem;" data-v-42ccd3fa><h1 class="project-title" data-v-42ccd3fa>Azure Functions in der Praxis: Automatische Bildverarbeitung im E-Commerce</h1> <div class="text-layout" data-v-8732a564 data-v-42ccd3fa><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Azure Functions in der Praxis: Automatische Bildverarbeitung im E-Commerce
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Nach vielen Jahren in der Softwareentwicklung habe ich gelernt: Die besten technischen Lösungen sind oft die unsichtbaren. Serverless Computing klang für mich lange nach Buzzword und Hype. Bis ich einen konkreten Use Case hatte, bei dem Azure Functions genau das richtige Werkzeug waren.

Dies ist die Geschichte, wie wir mit einer einfachen serverless Function ein wiederkehrendes Problem elegant gelöst haben – und was ich dabei über Serverless wirklich gelernt habe.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Der Kontext: E-Commerce und das Bildproblem
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Wir arbeiten an einem E-Commerce-Marktplatz, der auf Azure deployed ist. Wie in jedem Online-Shop sind Produktbilder zentral für die User Experience. Aber Produktbilder haben ein Problem:<b> Ein Bild passt nicht überall.</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Die Realität
    </h2> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Homepage-Kacheln brauchen kleine Thumbnails (schnell laden, Übersicht)</li><li data-v-8732a564>Produktlisten brauchen mittlere Bilder (Balance zwischen Qualität und Performance)</li><li data-v-8732a564>Produktdetailseiten brauchen große, hochauflösende Bilder (Zoom, Details)</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Unsere Bilder landen zunächst als Originale im <b>Azure Blob Storage</b> – hochgeladen von Händlern, Produktmanagern oder über APIs. <br><br><b>Das Problem:</b> Die Originale sind oft 3-5 MB groß. Für Thumbnails völlig überdimensioniert. Für Mobile katastrophal. Für Page Speed ein Desaster.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Das Problem: Jedes Bild in drei Größen – automatisch
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Die Anforderung war klar: <br><br><b>Jedes Produktbild muss in drei Formaten verfügbar sein:</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Thumbnail – kleine Vorschau</li><li data-v-8732a564>Medium – Standardansicht in Listen</li><li data-v-8732a564>Large – hochauflösend für Detailseiten</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Und zwar:</p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>✅ Automatisch bei jedem neuen Bild</li><li data-v-8732a564>✅ Bei jeder Änderung an existierenden Bildern</li><li data-v-8732a564>✅ Auch für alle bereits existierenden Bilder (Migration)</li></ul> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Warum das nicht trivial ist
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Option 1: On-the-fly Resizing beim Abruf</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Server muss bei jedem Request das Bild verarbeiten</li><li data-v-8732a564>Performance-Problem bei vielen gleichzeitigen Anfragen</li><li data-v-8732a564>Cache hilft, aber erster Request ist langsam</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Option 2: Manuell vor Upload</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Händler müssen 3 Versionen hochladen</li><li data-v-8732a564>Fehleranfällig, inkonsistent</li><li data-v-8732a564>Unmöglich für bereits existierende Tausende von Bildern</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Option 3: Cronjob auf einem Server</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Server läuft 24/7, auch wenn nichts zu tun ist</li><li data-v-8732a564>Polling ineffizient</li><li data-v-8732a564>Verzögerung zwischen Upload und Verfügbarkeit</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Was wir brauchten:</b> Eine Lösung, die automatisch reagiert, effizient läuft und nicht für Idle-Zeit kostet.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Die Lösung: Azure Functions + Blob Storage Trigger
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Ein Kollege schlug vor: <b>Azure Functions mit Blob Storage Trigger.</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Das Konzept
    </h2> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Neues Bild wird in Azure Blob Storage hochgeladen</li><li data-v-8732a564>Blob Storage feuert automatisch einen Event</li><li data-v-8732a564>Azure Function wird getriggert (ohne Polling, ohne Delay)</li><li data-v-8732a564>Python-Skript mit ImageMagick verarbeitet das Bild</li><li data-v-8732a564>Drei Versionen werden zurück in Blob Storage gespeichert</li></ul> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Die Architektur
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Mit Azure Functions:</p></div><div data-v-8732a564><pre class="section-code" data-v-8732a564><code data-v-8732a564>Original-Bild hochladen
        ↓
Azure Blob Storage (Input)
        ↓
[Blob Trigger feuert automatisch]
        ↓
Azure Function (Python + ImageMagick)
        ↓
Verarbeitung: Thumbnail, Medium, Large
        ↓
Azure Blob Storage (Output)
        ↓
Drei Formate verfügbar</code></pre></div><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Eine einfache, aber effektive Architektur – komplett automatisch und ohne manuelles Eingreifen.</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Warum Azure Functions?
    </h2> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564><b>Event-driven:</b> Kein Polling nötig. Die Function startet automatisch, wenn ein Blob hinzugefügt oder geändert wird.</li><li data-v-8732a564><b>Serverless:</b> Keine VM, die 24/7 läuft. Die Function existiert nur während der Ausführung. Du zahlst nur für die Sekunden, in denen sie läuft.</li><li data-v-8732a564><b>Auto-Scaling:</b> Kommen 100 Bilder gleichzeitig? Azure startet automatisch mehrere Instanzen parallel.</li><li data-v-8732a564><b>Managed Infrastructure:</b> Microsoft kümmert sich um Runtime, Updates, Verfügbarkeit. Wir schreiben nur Code.</li></ul> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Die technische Umsetzung
    </h2> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564><b>Python Runtime auf Azure Functions:</b> Python war die natürliche Wahl – einfach, gute Libraries für Bildverarbeitung, vom Team bekannt.</li><li data-v-8732a564><b>ImageMagick:</b> Open-Source Bildverarbeitungs-Tool. Kann Bilder skalieren, konvertieren, optimieren. Wird über Python aufgerufen.</li><li data-v-8732a564><b>Blob Trigger:</b> Azure Functions haben native Integration mit Blob Storage. Der Trigger-Code ist minimal – Azure macht den Rest.</li></ul> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Das Corrective Script
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Die Function löste neue Uploads. Aber was ist mit den <b>Tausenden bereits existierenden Bildern?</b><br><br>Dafür haben wir ein einmaliges Corrective Script geschrieben, das alle Bilder im Storage durchläuft, für jedes die Azure Function aufruft (oder direkt verarbeitet). Einmalige Migration, danach läuft alles automatisch.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Was funktioniert: Konkrete Erfolge
    </h2> <!----> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      1. Automatisierung ist komplett unsichtbar
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Das ist das beste Zeichen:</b><br><br>Niemand denkt mehr darüber nach.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Händler laden Bilder hoch → Sekunden später sind alle drei Formate verfügbar.</li><li data-v-8732a564>Kein manueller Schritt.</li><li data-v-8732a564>Keine Wartezeit.</li><li data-v-8732a564>Kein Support-Ticket.</li></ul> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      2. Performance der Website verbessert
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Vorher:</p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Homepage lud 3-5 MB Bilder, auch wenn nur Thumbnails angezeigt wurden</li><li data-v-8732a564>Langsame Ladezeiten, besonders auf Mobile</li><li data-v-8732a564>Schlechter Page Speed Score</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Nachher:</p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Thumbnails: ~50 KB statt 3 MB</li><li data-v-8732a564>Medium: ~200 KB</li><li data-v-8732a564>Large: Original-Qualität nur wo nötig</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Ergebnis:.</b> Messbar schnellere Ladezeiten, bessere User Experience</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      3. Kosteneffizienz
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Azure Functions Pricing ist nutzungsbasiert:</p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Du zahlst pro Ausführung und pro Sekunde Laufzeit</li><li data-v-8732a564>Bei moderatem Upload-Volumen (täglich neue Produkte, gelegentliche Updates) sind die Kosten minimal</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Im Vergleich zu einer VM, die 24/7 läuft:</p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Keine Idle-Kosten</li><li data-v-8732a564>Keine Wartung</li><li data-v-8732a564>Automatisches Scaling ohne Mehrkosten-Planung</li></ul> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      4. Einfache Wartung
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Der Code ist simpel. Ein Python-Skript, das ImageMagick aufruft. Keine komplexe Infrastruktur. Änderungen sind schnell deployed.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Was man beachten muss: Kritische Punkte
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Nach Monaten mit dieser Lösung im Einsatz habe ich auch gelernt: <b>Serverless ist kein Allheilmittel</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      1. Cold Start kann spürbar sein
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Wenn die Function längere Zeit nicht gelaufen ist, muss Azure eine neue Instanz starten. Das dauert ein paar Sekunden.<br><br><b>Bei uns:</b> Meist kein Problem, weil Bilder nicht in Echtzeit vor den Augen des Users verarbeitet werden. Aber bei interaktiven Use Cases (z.B. User lädt Bild hoch und will es sofort sehen) kann Cold Start nerven.<br><br><b>Lösung:</b> Premium Plan mit "Always On" – aber dann zahlst du wieder für Idle-Time.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      2. Debugging ist schwieriger
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Läuft etwas schief, ist Debugging komplizierter als auf einem normalen Server:</p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Logs sind in Azure Application Insights verstreut.</li><li data-v-8732a564>Lokales Testen braucht Azure Functions Core Tools.</li><li data-v-8732a564>Fehler sind schwerer nachzuvollziehen.</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Lektion:</b> Gutes Logging von Anfang an einbauen. Nicht nachträglich.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      3. Vendor Lock-in
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Azure Functions sind Azure-spezifisch. Code auf AWS Lambda zu migrieren bedeutet Anpassungen. Nicht unmöglich, aber auch nicht trivial.<br><br><b>Abwägung:</b> Für uns war die Developer Experience und native Azure-Integration wichtiger als Portabilität.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      4. ImageMagick in Serverless ist... speziell
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>ImageMagick ist ein externes Tool. In Azure Functions muss es als Dependency mitgepackt werden. Das macht das Deployment-Package größer und langsamer.<br><br><b>Alternative:</b> Managed Services wie Azure Cognitive Services für Bildverarbeitung. Teurer, aber einfacher.<br><br><b>Wir haben bei ImageMagick geblieben:</b> Mehr Kontrolle, günstiger, Use Case ist einfach genug.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      5. Nicht für alles geeignet
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Azure Functions sind perfekt für:</p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Event-driven Tasks</li><li data-v-8732a564>Kurzlaufende Operationen (< 10 Minuten)</li><li data-v-8732a564>Unvorhersehbare Last</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Azure Functions sind NICHT gut für:</p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Langläufige Prozesse (> 10 Minuten)</li><li data-v-8732a564>Konstant hohe Last (dann ist eine VM günstiger)</li><li data-v-8732a564>Sehr komplexes State Management</li></ul> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Learnings: Was ich wirklich mitgenommen habe
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Nach dieser Erfahrung mit Serverless habe ich verstanden:</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      1. Serverless heißt nicht &quot;kein Server&quot;
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Es heißt: <b>Du managst den Server nicht mehr.</b><br><br>Die Infrastruktur existiert noch. Du siehst sie nur nicht. Das ist Abstraktion, kein Verschwinden.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      2. Serverless ist Architektur-Entscheidung
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Man kann nicht einfach eine Anwendung "serverless machen". Serverless funktioniert für <b>spezifische Use Cases:</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Event-driven Workflows</li><li data-v-8732a564>Sporadische Tasks</li><li data-v-8732a564>Auto-Scaling-Bedarf</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Aber nicht als Ersatz für alles.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      3. Der ROI ist real – bei richtigem Einsatz
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Für unseren Use Case:</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Keine Wartung einer VM</li><li data-v-8732a564>Keine Idle-Kosten</li><li data-v-8732a564>Automatisches Scaling</li><li data-v-8732a564>Schnelle Entwicklung</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Das spart Zeit, Geld und Komplexität.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Aber:</b> Für andere Use Cases wäre eine VM oder Container günstiger und einfacher gewesen.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      4. Start simple, optimize later
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Unsere erste Version war simpel: Python + ImageMagick + Blob Trigger. Fertig.<br><br>Keine Micro-Optimierungen. Keine komplexe Architektur. <b>Es hat funktioniert.</b><br><br>Später kann man optimieren (Premium Plan, bessere Caching, alternative Libraries). Aber für den Start: <b>Simple is better.</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      5. Serverless ist Commodity geworden
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Vor 5 Jahren war Serverless experimentell. Heute ist es Standard. AWS Lambda, Azure Functions, Google Cloud Functions – alle großen Cloud-Anbieter haben es.<br><br><b>Das bedeutet:</b> Es ist nicht mehr Hype. Es ist ein Werkzeug im Toolbelt. Kein Muss, aber eine valide Option.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Wann würde ich Azure Functions empfehlen?
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Nach dieser Erfahrung würde ich Azure Functions (oder generell Serverless) empfehlen für:</p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564><b>✓ Event-driven Tasks</b> – Etwas muss passieren, wenn ein Event eintritt (Blob hochgeladen, Queue-Message, HTTP-Request).</li><li data-v-8732a564><b>✓ Sporadische Workloads</b> – Nicht 24/7, sondern gelegentlich – Serverless-Kosten unschlagbar.</li><li data-v-8732a564><b>✓ Prototyping und MVPs</b> – Schnell eine Idee testen, ohne Infrastruktur aufzusetzen.</li><li data-v-8732a564><b>✓ Glue Code zwischen Services</b> – Kleine Funktionen, die verschiedene Azure-Services verbinden.</li><li data-v-8732a564><b>✓ Auto-Scaling-Bedarf</b> – Last ist unvorhersehbar, Serverless skaliert automatisch.</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Aber Vorsicht bei:</p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564><b>✗ Langläufigen Prozessen</b> – Azure Functions haben Timeouts (Standard: 5 Min, max: 10 Min). Für längere Jobs: Azure Batch, Container, VMs.</li><li data-v-8732a564><b>✗ Konstant hoher Last</b> – Wenn Function 24/7 läuft, VM günstiger.</li><li data-v-8732a564><b>✗ Komplexem State Management</b> – Serverless ist stateless. Für komplexe Workflows: Durable Functions.</li><li data-v-8732a564><b>✗ Sehr niedrigen Latenz-Anforderungen</b> – Cold Start kann problematisch sein.</li></ul> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Der Blick nach vorne
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Diese Erfahrung mit Azure Functions hat mir gezeigt:<br><br><b>Technologie sollte zum Problem passen, nicht umgekehrt.</b><br><br>Wir hatten ein klares Problem: Bilder automatisch verarbeiten. Azure Functions waren dafür perfekt.<br><br>Aber ich würde nicht versuchen, alles in Functions zu packen. Manche Probleme brauchen VMs. Manche Container. Manche Serverless.<br><br><b>Die Kunst liegt darin, das richtige Werkzeug zu wählen.</b><br><br>Das ist die Denkweise, die ich aus 15 Jahren Entwicklung mitnehme: Nicht Trends folgen, sondern Probleme lösen. Nicht Hype glauben, sondern Vor- und Nachteile abwägen. Nicht Perfektion anstreben, sondern pragmatische Lösungen bauen, die funktionieren.<br><br>Denn am Ende geht es nicht um Serverless, Microservices oder Container.<br><br><b>Es geht darum, Software zu bauen, die echte Probleme löst – effizient, wartbar und mit Mehrwert für die Menschen, die damit arbeiten.</b></p></div></div> <!----></article></div></main></div></main> <footer class="blog-footer bg-primary text-white p-3 text-center">
  © 2025 Jalal El Saddi
</footer></div></div></div><script defer src="/jalalsaddi/_nuxt/static/1761557710/de/projects/azure-functions-in-practice/state.js"></script><script src="/jalalsaddi/_nuxt/d6a13ab.js" defer></script><script src="/jalalsaddi/_nuxt/51f5aa4.js" defer></script><script src="/jalalsaddi/_nuxt/e2f0863.js" defer></script><script src="/jalalsaddi/_nuxt/9478d7b.js" defer></script><script src="/jalalsaddi/_nuxt/2b0dd4f.js" defer></script>
  </body>
</html>
