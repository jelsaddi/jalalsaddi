<!doctype html>
<html data-n-head-ssr>
  <head>
    <meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="ssr" data-hid="description" name="description" content=""><title>Hexagonal Architecture in der Praxis: Warum sich weniger ändert, als man denkt</title><base href="/jalalsaddi/"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="favicon.ico"><link data-n-head="ssr" rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:100,200,300,400,500,600,700,800,900"><link data-n-head="ssr" rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i,800,800i"><link data-n-head="ssr" rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/simple-line-icons/2.4.1/css/simple-line-icons.css"><link data-n-head="ssr" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/konpa/devicon@df6431e323547add1b4cf45992913f15286456d3/devicon.min.css"><link data-n-head="ssr" rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous"><link data-n-head="ssr" rel="stylesheet" type="text/css" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous"><script data-n-head="ssr" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.1/js/solid.min.js"></script><script data-n-head="ssr" src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script><script data-n-head="ssr" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"></script><script data-n-head="ssr" src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script><link rel="preload" href="/jalalsaddi/_nuxt/b847b4e.js" as="script"><link rel="preload" href="/jalalsaddi/_nuxt/17625d1.js" as="script"><link rel="preload" href="/jalalsaddi/_nuxt/36f2891.js" as="script"><link rel="preload" href="/jalalsaddi/_nuxt/de6d152.js" as="script"><link rel="preload" href="/jalalsaddi/_nuxt/0704a89.js" as="script"><style data-vue-ssr-id="629c04aa:0 ff988300:0 306ea3c9:0 f88a5a40:0 2bef1f10:0 82aee578:0 516e6a4e:0">body{font-family:"Open Sans",serif;margin:0;padding:0}body,h1,h2,h3,h4,h5,h6{color:#343a40;color:var(--color-text-primary)}h1,h2,h3,h4,h5,h6{font-family:"Saira Extra Condensed",serif;font-weight:700;text-transform:uppercase}h1{font-size:6rem;line-height:5.5rem}h2{font-size:3.5rem}.subheading{font-family:"Saira Extra Condensed",serif;font-size:1.35rem;font-weight:500;text-transform:uppercase}.list-social-icons a{color:#7b5fc0;color:var(--color-primary)}.list-social-icons a:hover{color:#5e3d85;color:var(--color-primary-hover)}.list-social-icons a .fa-lg{font-size:1.75rem}.list-icons{font-size:3rem}.list-icons .list-inline-item i:hover{color:#5e3d85;color:var(--color-primary-hover)}#sideNav .navbar-nav .nav-item .nav-link{font-weight:600;text-transform:uppercase}@media (min-width:992px){#sideNav{display:flex;flex-direction:column;height:100vh;left:0;position:fixed;text-align:center;top:0;width:17rem}#sideNav .navbar-brand{display:flex;margin:auto auto 0;padding:.5rem}#sideNav .navbar-brand .img-profile{border:.5rem solid hsla(0,0%,100%,.2);max-height:10rem;max-width:10rem}#sideNav .navbar-collapse{align-items:flex-start;display:flex;flex-grow:0;margin-bottom:auto;width:100%}#sideNav .navbar-collapse .navbar-nav{flex-direction:column;width:100%}#sideNav .navbar-collapse .navbar-nav .nav-item,#sideNav .navbar-collapse .navbar-nav .nav-item .nav-link{display:block}}section.resume-section{border-bottom:1px solid #868e96;border-bottom:1px solid var(--color);padding-bottom:5rem!important;padding-top:5rem!important}section.resume-section .resume-item .resume-date{min-width:none}@media (min-width:768px){section.resume-section{min-height:100vh}section.resume-section .resume-item .resume-date{min-width:18rem}}@media (min-width:992px){section.resume-section{padding-bottom:3rem!important;padding-top:3rem!important}}.bg-primary{background-color:#7b5fc0!important;background-color:var(--color-primary)!important}.text-primary{color:#6a4ca0!important;color:var(--color-secondary)!important}a{color:#6a4ca0;color:var(--color-secondary)}a:active,a:focus,a:hover{color:#5e3d85;color:var(--color-primary-hover)}.vue-typer .custom.char{color:#343a40;color:var(--color-text-primary)}.card-body,.card-title{color:#868e96}:root{--color:#868e96;--color-primary:#7b5fc0;--color-secondary:#6a4ca0;--color-primary-hover:#5e3d85;--color-text-primary:#343a40;--color-text-secondary:#e2e2e2;--color-text-third:#343a40;--bg:#f3f5f4;--bg-secondary:#fff;--border-color:#ddd}.dark-mode{--color:#ebf4f1;--color-primary:#0a0d0f;--color-secondary:#000;--color-primary-hover:#020405;--color-text-primary:#fff;--color-text-secondary:#e2e2e2;--bg:#081927;--bg-secondary:#071521;--border-color:#0d2538}body{background-color:#f3f5f4;background-color:var(--bg);color:#868e96;color:var(--color);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Open Sans","Helvetica Neue",sans-seriff;transition:background-color .3s}a{color:#7b5fc0;color:var(--color-primary)}.nuxt-progress{background-color:#3b8070;height:2px;left:0;opacity:1;position:fixed;right:0;top:0;transition:width .1s,opacity .4s;width:0;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}.blog-layout{display:flex;flex-direction:column;min-height:100vh}.main-content{display:flex;flex:1;flex-direction:column}.content{flex:1}.blog-header[data-v-39f68977]{background:inherit;position:sticky;text-align:center;top:0;z-index:1000}.blog-header-title[data-v-39f68977]{color:#fff;font-family:Pacifico,cursive,"Saira Extra Condensed",serif;font-size:2rem;font-weight:700;letter-spacing:1px;margin:0;text-shadow:0 2px 8px rgba(0,0,0,.12)}.back-resume-btn[data-v-39f68977]{background:hsla(0,0%,100%,.1);border-radius:.25rem;color:#fff;font-size:.85rem;font-weight:600;padding:.3rem .75rem;position:absolute;right:1.5rem;-webkit-text-decoration:none;text-decoration:none;top:50%;transform:translateY(-50%);transition:background .2s}.back-resume-btn[data-v-39f68977]:hover{background:hsla(0,0%,100%,.25)}@media (max-width:767px){.blog-header[data-v-39f68977]{padding:1.2rem 1rem 1rem}.blog-header-title[data-v-39f68977]{font-size:1.3rem;margin-bottom:.5rem}.back-resume-btn[data-v-39f68977]{background:hsla(0,0%,100%,.15);display:inline-block;font-size:.9rem;margin-top:.5rem;position:static;transform:none}}.breadcrumb-container[data-v-6d559f88]{margin:.5rem 1rem}.breadcrumb[data-v-6d559f88]{background:0 0;display:flex;flex-wrap:nowrap;list-style:none;margin:0;padding:0;white-space:nowrap}.breadcrumb-item+.breadcrumb-item[data-v-6d559f88]:before{color:#666;content:">";padding:0 .5rem}.breadcrumb-item a[data-v-6d559f88]{color:var(--color-primary);-webkit-text-decoration:none;text-decoration:none}.breadcrumb-item.active[data-v-6d559f88]{color:#999}@media (max-width:767px){.breadcrumb-container[data-v-6d559f88]{font-size:.85rem;padding:.5rem .75rem}.breadcrumb-item+.breadcrumb-item[data-v-6d559f88]:before{padding:0 .25rem}.breadcrumb[data-v-6d559f88]{font-size:.85rem}.breadcrumb-item a[data-v-6d559f88],.breadcrumb-item span[data-v-6d559f88]{display:inline-block;max-width:120px;overflow:hidden;text-overflow:ellipsis;vertical-align:middle;white-space:nowrap}}.project-title[data-v-42ccd3fa]{font-size:2rem;font-weight:600;line-height:1.3;margin-bottom:2rem;text-align:center}.text-layout[data-v-8732a564]{color:#2d2d2d;font-size:1.05rem;line-height:1.7;margin:0 auto;max-width:850px}.text-section[data-v-8732a564]{border-bottom:1px solid #eaeaea;margin-bottom:2.2rem;padding-bottom:1.2rem}.section-title[data-v-8732a564]{color:#7b5fc0;font-size:1.5rem;font-weight:600;margin-bottom:.8rem}.section-content[data-v-8732a564]{margin:.5rem 0;text-align:justify}.section-bullets[data-v-8732a564]{list-style-type:disc;margin-left:1.5rem;margin-top:.5rem}.section-bullets li[data-v-8732a564]{margin-bottom:.4rem}.section-code[data-v-8732a564]{background:hsla(0,0%,50%,.31);border-radius:.25rem;font-family:monospace;font-size:.95rem;margin:1rem 0;overflow-x:auto;padding:1rem}table[data-v-8732a564]{border-collapse:collapse;width:100%}td[data-v-8732a564],th[data-v-8732a564]{text-align:left}tr[data-v-8732a564]:hover{background-color:#f9f9ff}.inline-code[data-v-8732a564]{background:#eee;border-radius:.2rem;font-family:monospace;font-size:.95rem;padding:.1rem .3rem}.dark-mode .section-bullets li[data-v-8732a564],.dark-mode .section-content[data-v-8732a564],.dark-mode .section-title[data-v-8732a564],.dark-mode .text-layout[data-v-8732a564]{color:#fff!important}.dark-mode .section-code[data-v-8732a564]{background:#333;color:#fff}.dark-mode table tr[data-v-8732a564]:hover{background-color:#444}</style><link rel="preload" href="/jalalsaddi/_nuxt/static/1761294362/de/projects/hexagonal-architecture-in-practice/state.js" as="script"><link rel="preload" href="/jalalsaddi/_nuxt/static/1761294362/de/projects/hexagonal-architecture-in-practice/payload.js" as="script"><link rel="preload" href="/jalalsaddi/_nuxt/static/1761294362/manifest.js" as="script">
  </head>
  <body>
    <script data-n-head="ssr" data-hid="nuxt-color-mode-script" data-pbody="true">!function(){"use strict";var e=window,t=document,s=t.documentElement,r=["dark","light"],n=function(){for(var e="nuxt-color-mode=",s=t.cookie.split(";"),r=0;r<s.length;r++){for(var n=s[r];" "===n.charAt(0);)n=n.substring(1,n.length);if(0===n.indexOf(e))return n.substring(16,n.length)}return null}()||"system",a="system"===n?i():n;function c(e){var t=e+"-mode";s.classList?s.classList.add(t):s.className+=" "+t}function o(t){return e.matchMedia("(prefers-color-scheme"+t+")")}function i(){if(e.matchMedia&&"not all"!==o("").media)for(var t of r)if(o(":"+t).matches)return t;return"light"}c(a),e.__NUXT_COLOR_MODE__={preference:n,value:a,getColorScheme:i,addClass:c,removeClass:function(e){var t=e+"-mode";s.classList?s.classList.remove(t):s.className=s.className.replace(new RegExp(t,"g"),"")}}}()</script><div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="blog-layout"><header class="blog-header bg-primary text-white" data-v-39f68977><h1 class="blog-header-title" data-v-39f68977>Blog & Projects</h1> <a href="/jalalsaddi/de/" class="back-resume-btn nuxt-link-active" data-v-39f68977>
    Zurück zum Lebenslauf
  </a></header> <nav aria-label="breadcrumb" class="breadcrumb-container" data-v-6d559f88><ol class="breadcrumb" data-v-6d559f88><li class="breadcrumb-item" data-v-6d559f88><a href="/jalalsaddi/" class="nuxt-link-active" data-v-6d559f88>
        Home
      </a></li><li class="breadcrumb-item" data-v-6d559f88><a href="/jalalsaddi/blog" data-v-6d559f88>
        Blog
      </a></li><li class="breadcrumb-item active" data-v-6d559f88><span data-v-6d559f88>Hexagonal Architecture in der Praxis: Warum sich weniger ändert, als man denkt</span></li></ol></nav> <main class="main-content"><div class="container content"><main class="container flex-grow-1" style="padding-top:8rem;padding-bottom:5.5rem" data-v-42ccd3fa><h1 class="project-title" data-v-42ccd3fa>Hexagonal Architecture in der Praxis: Warum sich weniger ändert, als man denkt</h1> <div class="text-layout" data-v-8732a564 data-v-42ccd3fa><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Hexagonal Architecture in der Praxis: Warum sich weniger ändert, als man denkt
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Nach 15 Jahren in der Softwareentwicklung hatte ich letzte Woche einen Aha-Moment. Ich las über Hexagonal Architecture, Ports & Adapters, Clean Architecture – und plötzlich wurde mir klar: <b>Das haben wir vor 15 Jahren auch schon gemacht. Nur mit anderen Namen.</b><br><br>Die Frameworks haben sich geändert. Die Buzzwords sind neu. Aber die Prinzipien? Die sind die gleichen geblieben.<br><br>Diese Erkenntnis hat meine Perspektive auf moderne Software-Architektur grundlegend verändert – und sie zeigt etwas Wichtiges: <b>Technology keeps changing, but the principles barely move.</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Der Kontext: Wo kam ich her?
    </h2> <!----> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Vor 15 Jahren: Die "alte" Java-Welt
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Als ich anfing zu programmieren, war der Java-Enterprise-Stack noch ganz anders:</p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Struts als Web-Framework</li><li data-v-8732a564>Spring für Dependency Injection (aber noch mit XML-Konfiguration)</li><li data-v-8732a564>iBatis (später MyBatis) für Datenbank-Zugriff</li><li data-v-8732a564>JSP für Views</li><li data-v-8732a564>Deployment als WAR-Files auf Tomcat oder JBoss</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Das war der Standard. Das haben wir gelernt. Das galt als "professionell".</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Wie wir damals Architekturen gebaut haben
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Wir haben in Schichten gedacht:</p></div><div data-v-8732a564><pre class="section-code" data-v-8732a564><code data-v-8732a564>Presentation Layer
  (Struts Actions, JSPs)
        ↓
Business Logic Layer
  (Service Classes)
        ↓
Data Access Layer
  (DAO Interfaces, iBatis)
        ↓
Database</code></pre></div><div data-v-8732a564><p class="section-content" data-v-8732a564></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Unsere Prinzipien waren klar:</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564><b>Separation of Concerns:</b> Jede Schicht hat eine Aufgabe</li><li data-v-8732a564><b>Interfaces überall:</b> DAOs waren immer Interfaces</li><li data-v-8732a564><b>Business Logic unabhängig:</b> Service-Layer kannte keine HTTP-Details</li><li data-v-8732a564><b>Testbar:</b> Unit Tests für Services, Mock-DAOs für Tests</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Das war unsere "Best Practice" – lange bevor jemand von Hexagonal Architecture sprach.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Das Problem: Der Wandel der Technologie
    </h2> <!----> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Die Jahre vergingen, neue Frameworks kamen
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Über die Jahre hat sich der Stack dramatisch verändert:<br><br><b>2010er Jahre:</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Struts → Spring MVC</li><li data-v-8732a564>XML → Annotations</li><li data-v-8732a564>WAR → Embedded Tomcat</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>2020er Jahre:</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Spring Boot als Standard</li><li data-v-8732a564>Microservices-Architekturen</li><li data-v-8732a564>Container (Docker, Kubernetes)</li><li data-v-8732a564>REST APIs statt JSPs</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Und plötzlich neue Buzzwords:</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Hexagonal Architecture</li><li data-v-8732a564>Ports & Adapters</li><li data-v-8732a564>Clean Architecture</li><li data-v-8732a564>Domain-Driven Design</li></ul> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Die Verunsicherung
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Als ich diese neuen Begriffe hörte, dachte ich zunächst:<br><br>"Ist unsere alte Architektur veraltet? Haben wir es falsch gemacht? Müssen wir alles neu lernen?"<br><br>Konferenzen voller Talks über "moderne Architektur". Bücher über Clean Code und Domain-Driven Design. YouTube-Videos über Hexagonal Architecture.<br><br><b>Die implizite Botschaft:</b> "Das Alte ist schlecht, das Neue ist besser."</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Die Lösung: Der Blick hinter die Buzzwords
    </h2> <!----> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Der Aha-Moment
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Letzte Woche saß ich mit einem Kollegen zusammen und wir diskutierten über Hexagonal Architecture. Er zeigte mir ein Diagramm:</p></div><div data-v-8732a564><pre class="section-code" data-v-8732a564><code data-v-8732a564>REST Controller (Adapter)
        ↓
Application Service (Port)
        ↓
Domain Logic (Core)
        ↓
Repository Interface (Port)
        ↓
Repository Impl (Adapter)</code></pre></div><div data-v-8732a564><p class="section-content" data-v-8732a564>Ich schaute es an – und mir fiel die Kinnlade runter.

<b>Das ist exakt das, was wir vor 15 Jahren auch gemacht haben!</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Der Vergleich: Damals vs. Heute
    </h2> <div data-v-8732a564><table class="hidden md:table w-full border-collapse" data-v-8732a564><thead data-v-8732a564><tr class="bg-gray-100" data-v-8732a564><th class="p-2 border text-red-600" data-v-8732a564>Damals (2010)</th> <th class="p-2 border text-green-600" data-v-8732a564>Heute (2025)</th> <th class="p-2 border text-indigo-600" data-v-8732a564>Das Prinzip</th></tr></thead> <tbody data-v-8732a564><tr class="hover:bg-gray-50" data-v-8732a564><td class="p-2 border bg-red-50 text-gray-800" data-v-8732a564>Struts Action</td> <td class="p-2 border bg-green-50 text-gray-800" data-v-8732a564>REST Controller (Adapter)</td> <td class="p-2 border bg-gray-50 text-gray-800" data-v-8732a564>Eingangs-Schnittstelle zur Außenwelt</td></tr><tr class="hover:bg-gray-50" data-v-8732a564><td class="p-2 border bg-red-50 text-gray-800" data-v-8732a564>Service Interface + Impl</td> <td class="p-2 border bg-green-50 text-gray-800" data-v-8732a564>Application Service (Port)</td> <td class="p-2 border bg-gray-50 text-gray-800" data-v-8732a564>Business-Logik-Abstraktion</td></tr><tr class="hover:bg-gray-50" data-v-8732a564><td class="p-2 border bg-red-50 text-gray-800" data-v-8732a564>Service-Methoden</td> <td class="p-2 border bg-green-50 text-gray-800" data-v-8732a564>Use Cases</td> <td class="p-2 border bg-gray-50 text-gray-800" data-v-8732a564>Konkrete Business-Operationen</td></tr><tr class="hover:bg-gray-50" data-v-8732a564><td class="p-2 border bg-red-50 text-gray-800" data-v-8732a564>DAO Interface</td> <td class="p-2 border bg-green-50 text-gray-800" data-v-8732a564>Repository Port</td> <td class="p-2 border bg-gray-50 text-gray-800" data-v-8732a564>Persistenz-Abstraktion</td></tr><tr class="hover:bg-gray-50" data-v-8732a564><td class="p-2 border bg-red-50 text-gray-800" data-v-8732a564>iBatis Mapper</td> <td class="p-2 border bg-green-50 text-gray-800" data-v-8732a564>Repository Adapter</td> <td class="p-2 border bg-gray-50 text-gray-800" data-v-8732a564>Konkrete Datenbankanbindung</td></tr></tbody></table></div> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Es ist das Gleiche. Nur die Namen haben sich geändert.</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Was wirklich neu ist (und was nicht)
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Wirklich neu:</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>✅ Syntax: @RestController statt XML-Konfiguration</li><li data-v-8732a564>✅ Tools: Spring Boot vs. Struts + XML</li><li data-v-8732a564>✅ Deployment: Container vs. WAR-Files</li><li data-v-8732a564>✅ Terminologie: "Ports & Adapters" vs. "DAOs"</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>NICHT neu:</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>❌ Separation of Concerns</li><li data-v-8732a564>❌ Dependency Inversion</li><li data-v-8732a564>❌ Abstraktion über Interfaces</li><li data-v-8732a564>❌ Testability durch Mocking</li><li data-v-8732a564>❌ Lose Kopplung zwischen Schichten</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Die Prinzipien sind identisch. Nur die Verpackung ist moderner.</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      1. Separation of Concerns funktioniert seit Jahrzehnten
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Damals:</b><br><br></p></div></div> <div class="mt-4" data-v-8732a564><h3 class="font-semibold text-gray-700 mb-2" data-v-8732a564>Code Snippets</h3> <div class="section-code" data-v-8732a564><pre data-v-8732a564><code data-v-8732a564>// Struts Action (2010)
public class UserAction extends Action {
    private UserService userService; // injected
    public ActionForward execute(...) {
        User user = userService.findById(id);
        request.setAttribute("user", user);
        return mapping.findForward("success");
    }
}</code></pre></div> <!----></div></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Heute:</b><br><br></p></div></div> <div class="mt-4" data-v-8732a564><h3 class="font-semibold text-gray-700 mb-2" data-v-8732a564>Code Snippets</h3> <div class="section-code" data-v-8732a564><pre data-v-8732a564><code data-v-8732a564>// REST Controller (2025)
@RestController
public class UserController {
    private final UserService userService;
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
}</code></pre></div> <div class="mt-2" data-v-8732a564><b>Unterschied:</b> Syntax. Prinzip: Das Gleiche – Controller delegiert an Service.</div></div></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      2. Dependency Inversion war schon immer klug
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Damals:</b><br><br></p></div></div> <div class="mt-4" data-v-8732a564><h3 class="font-semibold text-gray-700 mb-2" data-v-8732a564>Code Snippets</h3> <div class="section-code" data-v-8732a564><pre data-v-8732a564><code data-v-8732a564>// Service Layer (2010)
public class UserServiceImpl implements UserService {
    private UserDAO userDAO; // Interface!
    public User findById(Long id) {
        return userDAO.findById(id);
    }
}</code></pre></div> <!----></div></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Heute:</b><br><br></p></div></div> <div class="mt-4" data-v-8732a564><h3 class="font-semibold text-gray-700 mb-2" data-v-8732a564>Code Snippets</h3> <div class="section-code" data-v-8732a564><pre data-v-8732a564><code data-v-8732a564>// Application Service (2025)
@Service
public class UserService {
    private final UserRepository userRepository; // Interface!
    public User findById(Long id) {
        return userRepository.findById(id);
    }
}</code></pre></div> <div class="mt-2" data-v-8732a564><b>Unterschied:</b> Annotation. <b>Prinzip:</b> Das Gleiche – abhängig von Abstraktion, nicht Implementierung.</div></div></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      3. Testability durch Interfaces war immer wichtig
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Damals:</b><br><br></p></div></div> <div class="mt-4" data-v-8732a564><h3 class="font-semibold text-gray-700 mb-2" data-v-8732a564>Code Snippets</h3> <div class="section-code" data-v-8732a564><pre data-v-8732a564><code data-v-8732a564>// Unit Test (2010)
public class UserServiceTest {
    @Test
    public void testFindById() {
        UserDAO mockDAO = mock(UserDAO.class);
        when(mockDAO.findById(1L)).thenReturn(testUser);
        UserService service = new UserServiceImpl(mockDAO);
        User result = service.findById(1L);
        assertEquals("John", result.getName());
    }
}</code></pre></div> <!----></div></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Heute:</b><br><br></p></div></div> <div class="mt-4" data-v-8732a564><h3 class="font-semibold text-gray-700 mb-2" data-v-8732a564>Code Snippets</h3> <div class="section-code" data-v-8732a564><pre data-v-8732a564><code data-v-8732a564>// Unit Test (2025)
@Test
public void testFindById() {
    UserRepository mockRepo = mock(UserRepository.class);
    when(mockRepo.findById(1L)).thenReturn(Optional.of(testUser));
    UserService service = new UserService(mockRepo);
    User result = service.findById(1L);
    assertEquals("John", result.getName());
}</code></pre></div> <div class="mt-2" data-v-8732a564><b>Unterschied:</b> Minimal. <b>Prinzip:</b> Exakt das Gleiche – Mock die Abhängigkeit, teste die Logik.</div></div></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Die Erkenntnis
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Wir haben keine schlechte Architektur gebaut.</b><br><br>Wir haben <b>solide Prinzipien</b> angewendet:</p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Loose Coupling</li><li data-v-8732a564>Dependency Inversion</li><li data-v-8732a564>Separation of Concerns</li><li data-v-8732a564>Testability</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Die Industrie hat diese Prinzipien nur <b>neu verpackt und umbenannt:</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>"DAO" → "Repository"</li><li data-v-8732a564>"Service Layer" → "Application Service" / "Use Case"</li><li data-v-8732a564>"Layered Architecture" → "Hexagonal Architecture" / "Clean Architecture"</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Die Prinzipien waren immer da. Wir haben nur neue Worte dafür gefunden.</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      2. Prinzipien wichtiger als Namen
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Der Fehler:</b> Stunden damit verbringen, zu diskutieren: "Ist das jetzt ein Port oder ein Adapter?"<br><br><b>Die Realität:</b> Die Frage sollte sein: "Ist diese Komponente testbar? Ist sie entkoppelt? Ist sie wartbar?"<br><br><b>Namen sind Kommunikationsmittel, keine Dogmen.</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      3. Hype vs. Substanz unterscheiden
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Frameworks kommen und gehen:</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Struts (tot)</li><li data-v-8732a564>JSF (fast tot)</li><li data-v-8732a564>Spring MVC (Standard, aber wird weniger)</li><li data-v-8732a564>React (aktuell Hype)</li><li data-v-8732a564>Next.js (noch neuerer Hype)</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Prinzipien bleiben:</p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>SOLID (seit 2000, immer noch gültig)</li><li data-v-8732a564>Separation of Concerns (seit 1970er)</li><li data-v-8732a564>Dependency Inversion (seit immer)</li><li data-v-8732a564>Testability (seit immer)</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Investiere in Prinzipien, nicht in Hype.</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      4. Alte Code-Basen sind nicht automatisch schlecht
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Der Fehler:</b> "Dieser Code ist 10 Jahre alt, der muss schlecht sein!"<br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Die Realität:</b> Wenn der Code sauber strukturiert ist, testbar ist und funktioniert – dann ist er <b>gut</b>, egal wie alt.<br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Alter ≠ Qualität. Struktur = Qualität.</b></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Learnings: Was ich wirklich mitgenommen habe
    </h2> <!----> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      1. Frameworks sind Werkzeuge, Prinzipien sind Fundamente
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Als Junior (vor 15 Jahren):</b> Ich dachte: "Struts ist DIE Art, Web-Anwendungen zu bauen."<br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Als Senior (heute):</b> Ich weiß: "Struts war EIN Werkzeug, das mir half, gute Prinzipien anzuwenden."<br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Die Lektion:</b> Wenn du die Prinzipien verstehst (Separation, Decoupling, Testability), kannst du <b>jedes Framework lernen.</b><br><br>Wenn du nur Frameworks auswendig lernst, bist du verloren, sobald ein neues kommt.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      2. "Modern" ist relativ
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Heute modern:</b><br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Hexagonal Architecture</li><li data-v-8732a564>Domain-Driven Design</li><li data-v-8732a564>Microservices</li><li data-v-8732a564>Serverless</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>In 10 Jahren:</b><br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Werden neue Buzzwords existieren</li><li data-v-8732a564>Werden heutige "moderne" Frameworks Legacy sein</li><li data-v-8732a564>Werden die gleichen Prinzipien immer noch gelten</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Die Lektion:</b> Jage nicht Trends. Verstehe Prinzipien.</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      3. Erfahrung bedeutet Muster erkennen
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Das ist der Unterschied zwischen Junior und Senior:</b><br><br><b>Junior:</b> "Hexagonal Architecture ist neu, ich muss es lernen!"<br><br><b>Senior:</b> "Hexagonal Architecture? Das ist wie DAO-Pattern mit neuem Namen."<br><br><b>Die Lektion:</b> Mit Erfahrung siehst du, dass sich vieles wiederholt – nur mit anderen Worten.<br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      4. Gute Architektur ist zeitlos
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Kriterien für gute Architektur (2010):</b><br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Testbar</li><li data-v-8732a564>Wartbar</li><li data-v-8732a564>Erweiterbar</li><li data-v-8732a564>Entkoppelt</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Kriterien für gute Architektur (2025):</b><br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Testbar</li><li data-v-8732a564>Wartbar</li><li data-v-8732a564>Erweiterbar</li><li data-v-8732a564>Entkoppelt</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Die Lektion:</b> Diese Kriterien haben sich <b>nicht geändert.</b> Und sie werden sich auch in 10 Jahren nicht ändern.<br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      5. Bescheidenheit gegenüber der Vergangenheit
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Früher dachte ich:</b> "Die alten Entwickler haben es nicht verstanden. Wir machen es heute besser."<br><br><b>Heute weiß ich:</b> "Die alten Entwickler haben die gleichen Prinzipien verstanden. Sie hatten nur andere Tools."<br><br><b>Die Lektion:</b> Respekt vor der Arbeit früherer Entwickler. Sie haben oft <b>sehr gut</b> gearbeitet – nur mit anderen Mitteln.<br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Der Blick nach vorne
    </h2> <!----> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Was bedeutet das für meine Arbeit?
    </h2> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Diese Erkenntnis hat meine Perspektive fundamental verändert:<br><br><b>Ich frage nicht mehr:</b> "Ist dieses Framework modern?"<br><b>Ich frage:</b> "Hilft mir dieses Framework, gute Prinzipien umzusetzen?"<br><br><b>Ich frage nicht mehr:</b> "Müssen wir zu Hexagonal Architecture migrieren?"<br><b>Ich frage:</b> "Ist unsere Architektur testbar, wartbar und entkoppelt?"<br><br><b>Ich falle nicht mehr auf Hype rein.</b><br><b>Ich fokussiere mich auf zeitlose Prinzipien.</b><br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Was empfehle ich anderen?
    </h2> <!----> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Für Junior-Entwickler:</b><br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>❌ <b>Nicht:</b> "Lerne Hexagonal Architecture auswendig"</li><li data-v-8732a564>✅ <b>Besser:</b> "Verstehe, WARUM wir Schichten trennen und Abhängigkeiten umkehren"</li><li data-v-8732a564>❌ <b>Nicht:</b> "Spring Boot ist DIE Lösung"</li><li data-v-8732a564>✅ <b>Besser:</b> "Spring Boot ist EIN Werkzeug, das Prinzipien umsetzt"</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Wenn du die Prinzipien verstehst:</b><br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Kannst du jedes Framework lernen</li><li data-v-8732a564>Erkennst du gute vs. schlechte Architektur</li><li data-v-8732a564>Bist du nicht abhängig von Trends</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Für Senior-Entwickler:</b><br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>❌ <b>Nicht:</b> "Unsere alte Architektur ist veraltet"</li><li data-v-8732a564>✅ <b>Besser:</b> "Unsere Architektur folgt soliden Prinzipien – das zählt"</li><li data-v-8732a564>❌ <b>Nicht:</b> "Wir müssen auf Hexagonal refactoren"</li><li data-v-8732a564>✅ <b>Besser:</b> "Haben wir ein Problem, das Hexagonal lösen würde?"</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Refactore nur mit klarem Grund, nicht wegen Buzzwords.</b><br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      In 15 Jahren
    </h2> <!----> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Was wird anders sein:</b><br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Spring Boot wird vielleicht Legacy sein</li><li data-v-8732a564>Neue Frameworks werden existieren</li><li data-v-8732a564>Neue Buzzwords werden Konferenzen füllen</li><li data-v-8732a564>Neue Annotations werden erfunden</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Was gleich bleiben wird:</b><br><br></p></div></div> <!----></article><article class="text-section" data-v-8732a564><!----> <ul class="section-bullets" data-v-8732a564><li data-v-8732a564>Separation of Concerns wird wichtig sein</li><li data-v-8732a564>Testability wird zählen</li><li data-v-8732a564>Loose Coupling wird gelten</li><li data-v-8732a564>Dependency Inversion wird funktionieren</li></ul> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564><b>Denn wie ein kluger Entwickler mal sagte:</b><br><br>"Technology keeps changing, but the principles barely move."<br><br><b>Oder noch prägnanter:</b><br><br>"Nothing's really new. It just gets a new name, a new annotation, and a new conference talk."</p></div></div> <!----></article><article class="text-section" data-v-8732a564><h2 class="section-title" data-v-8732a564>
      Fazit: Prinzipien über Frameworks
    </h2> <!----> <!----></article><article class="text-section" data-v-8732a564><!----> <div data-v-8732a564><div data-v-8732a564><p class="section-content" data-v-8732a564>Nach 15 Jahren in der Softwareentwicklung ist das meine wichtigste Erkenntnis:<br><br><b>Frameworks sind temporär. Prinzipien sind ewig.</b><br><br>Struts ist tot. iBatis ist umbenannt. XML-Konfiguration ist out.<br><br>Aber Separation of Concerns? Dependency Inversion? Testability?<br><br><b>Die werden noch in 50 Jahren gelten.</b><br><br>Das ist nicht Nostalgie. Das ist nicht Widerstand gegen Neues.<br><br><b>Es ist Weisheit aus Erfahrung:</b><br><br>Die besten Entwickler sind nicht die, die jeden neuen Trend mitgehen.<br>Die besten Entwickler sind die, die verstehen, <b>was unter der Oberfläche wirklich zählt.</b><br><br>Und das sind nicht Frameworks.<br><b>Das sind Prinzipien.</b></p></div></div> <!----></article></div></main></div></main> <footer class="blog-footer bg-primary text-white p-3 text-center">
  © 2025 Jalal El Saddi
</footer></div></div></div><script defer src="/jalalsaddi/_nuxt/static/1761294362/de/projects/hexagonal-architecture-in-practice/state.js"></script><script src="/jalalsaddi/_nuxt/b847b4e.js" defer></script><script src="/jalalsaddi/_nuxt/0704a89.js" defer></script><script src="/jalalsaddi/_nuxt/17625d1.js" defer></script><script src="/jalalsaddi/_nuxt/36f2891.js" defer></script><script src="/jalalsaddi/_nuxt/de6d152.js" defer></script>
  </body>
</html>
