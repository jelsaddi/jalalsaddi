(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{354:function(e,n,t){"use strict";var r=t(1),o=t(237).trim;r({target:"String",proto:!0,forced:t(355)("trim")},{trim:function(){return o(this)}})},355:function(e,n,t){"use strict";var r=t(102).PROPER,o=t(4),l=t(238);e.exports=function(e){return o(function(){return!!l[e]()||"​᠎"!=="​᠎"[e]()||r&&l[e].name!==e})}},362:function(e,n,t){var content=t(404);content.__esModule&&(content=content.default),"string"==typeof content&&(content=[[e.i,content,""]]),content.locals&&(e.exports=content.locals);(0,t(62).default)("210115b4",content,!0,{sourceMap:!1})},363:function(e,n,t){var content=t(406);content.__esModule&&(content=content.default),"string"==typeof content&&(content=[[e.i,content,""]]),content.locals&&(e.exports=content.locals);(0,t(62).default)("30423bfe",content,!0,{sourceMap:!1})},364:function(e,n,t){var content=t(408);content.__esModule&&(content=content.default),"string"==typeof content&&(content=[[e.i,content,""]]),content.locals&&(e.exports=content.locals);(0,t(62).default)("516e6a4e",content,!0,{sourceMap:!1})},365:function(e,n,t){var content=t(412);content.__esModule&&(content=content.default),"string"==typeof content&&(content=[[e.i,content,""]]),content.locals&&(e.exports=content.locals);(0,t(62).default)("82aee578",content,!0,{sourceMap:!1})},403:function(e,n,t){"use strict";t(362)},404:function(e,n,t){var r=t(61)(function(i){return i[1]});r.push([e.i,".accordion-item[data-v-1e4061e5]{border-bottom:1px solid #ddd;border-radius:.25rem;margin-bottom:.5rem;overflow:hidden}.accordion-header[data-v-1e4061e5]{align-items:center;background:#e5dbf8;border-radius:.25rem;cursor:pointer;display:flex;font-weight:600;justify-content:space-between;padding:.75rem 1rem;transition:background .3s}.accordion-header[data-v-1e4061e5]:hover{background:#d8c7f5}.accordion-header.active[data-v-1e4061e5]{background:#7b5fc0;color:#fff}.arrow[data-v-1e4061e5]{font-size:.9rem;transition:transform .3s ease}.arrow.open[data-v-1e4061e5]{transform:rotate(180deg)}.accordion-content[data-v-1e4061e5]{background:#fff;padding:1rem}.accordion-enter-active[data-v-1e4061e5],.accordion-leave-active[data-v-1e4061e5]{transition:all .3s ease}.accordion-enter[data-v-1e4061e5],.accordion-leave-to[data-v-1e4061e5]{max-height:0;opacity:0;overflow:hidden}.accordion-enter-to[data-v-1e4061e5],.accordion-leave[data-v-1e4061e5]{max-height:500px;opacity:1}",""]),r.locals={},e.exports=r},405:function(e,n,t){"use strict";t(363)},406:function(e,n,t){var r=t(61)(function(i){return i[1]});r.push([e.i,".dark-mode .accordion-header{background:#222;color:#fff}.dark-mode .accordion-header.active{background:#000;color:#fff}.dark-mode .accordion-content{background:#fff;color:#000}.dark-mode .accordion-header:hover{background:#333}",""]),r.locals={},e.exports=r},407:function(e,n,t){"use strict";t(364)},408:function(e,n,t){var r=t(61)(function(i){return i[1]});r.push([e.i,".text-layout[data-v-8732a564]{color:#2d2d2d;font-size:1.05rem;line-height:1.7;margin:0 auto;max-width:850px}.text-section[data-v-8732a564]{border-bottom:1px solid #eaeaea;margin-bottom:2.2rem;padding-bottom:1.2rem}.section-title[data-v-8732a564]{color:#7b5fc0;font-size:1.5rem;font-weight:600;margin-bottom:.8rem}.section-content[data-v-8732a564]{margin:.5rem 0;text-align:justify}.section-bullets[data-v-8732a564]{list-style-type:disc;margin-left:1.5rem;margin-top:.5rem}.section-bullets li[data-v-8732a564]{margin-bottom:.4rem}.section-code[data-v-8732a564]{background:hsla(0,0%,50%,.31);border-radius:.25rem;font-family:monospace;font-size:.95rem;margin:1rem 0;overflow-x:auto;padding:1rem}table[data-v-8732a564]{border-collapse:collapse;width:100%}td[data-v-8732a564],th[data-v-8732a564]{text-align:left}tr[data-v-8732a564]:hover{background-color:#f9f9ff}.inline-code[data-v-8732a564]{background:#eee;border-radius:.2rem;font-family:monospace;font-size:.95rem;padding:.1rem .3rem}.dark-mode .section-bullets li[data-v-8732a564],.dark-mode .section-content[data-v-8732a564],.dark-mode .section-title[data-v-8732a564],.dark-mode .text-layout[data-v-8732a564]{color:#fff!important}.dark-mode .section-code[data-v-8732a564]{background:#333;color:#fff}.dark-mode table tr[data-v-8732a564]:hover{background-color:#444}",""]),r.locals={},e.exports=r},409:function(e){e.exports=JSON.parse('[{"slug":"german-nouns","title":"Planning and Development of the Flutter App \\"German Articles Trainer\\"","layout":"accordion","sections":[{"heading":"Introduction","content":"Learning German articles — der, die, das — is one of the biggest challenges for learners of the German language. Articles don’t always follow logical rules, and memorization often feels frustrating. The goal of this app is to make article practice easier, interactive, and motivating."},{"heading":"Concept & Planning","content":"From the beginning, the app was designed around three key principles: Clarity – Learners should focus only on what matters: nouns and their articles. Engagement – Flashcards, quizzes, and progress tracking keep motivation high. Accessibility – Cross-platform availability (Android and iOS) ensures wide reach."},{"heading":"Target Audience","content":"Beginners (A1–A2) who want to practice the basics. Intermediate learners (B1) who want to strengthen accuracy."},{"heading":"Core Features","content":"Flashcards for learning articles. Quiz mode with instant feedback. Progress statistics (correct/incorrect attempts). Offline support with a local database."},{"heading":"Technical Stack & Tools","content":"Language & Framework: Dart with Flutter. UI Design: Implemented directly with Flutter’s Material Design widgets. Data Storage: SQLite for storing nouns, articles, and user progress. State Management: Provider for clean state handling. Version Control: GitHub for collaborative development and backup."}]},{"slug":"german-words-app","title":"Planning and Development of the Flutter App \\"German Words App\\"","layout":"accordion","sections":[{"heading":"Introduction","content":"The German Words App helps learners practice nouns, verbs, and adjectives in a fun and interactive way. It focuses on building vocabulary and reinforcing grammar rules in context."},{"heading":"Concept & Planning","content":"The app was designed with clarity, engagement, and accessibility in mind. Users can practice vocabulary through flashcards, quizzes, and interactive exercises."},{"heading":"Target Audience","content":"Beginners (A1–A2) learning basic words, intermediate learners (B1–B2) who want to expand their vocabulary and improve grammar accuracy, and advanced learners (C1–C2) who want to master nuanced vocabulary and idiomatic expressions."},{"heading":"Levels","content":"The app covers all levels of the CEFR:\\n\\nA1 – Basic words and phrases.\\nA2 – Simple sentences and everyday vocabulary.\\nB1 – Intermediate vocabulary and grammar structures.\\nB2 – Complex sentences, idioms, and expanded vocabulary.\\nC1 – Advanced vocabulary, nuanced meanings, and professional topics.\\nC2 – Near-native proficiency, including idiomatic expressions and subtleties."},{"heading":"Core Features","content":"Flashcards for nouns, verbs, and adjectives. Quiz mode with instant feedback. Progress statistics with performance charts. Offline support using local database."},{"heading":"Technical Stack & Tools","content":"Flutter with Dart. Material Design UI. SQLite for local storage. Provider for state management. GitHub for version control."},{"heading":"App Architecture","content":"Home Screen – navigate to different practice modes. Learning Mode – cards for words with correct articles/verbs/adjectives. Quiz Mode – randomized questions. Statistics Screen – overview of progress."},{"heading":"Development Process","content":"Project Setup: Flutter project with Dart SDK. Added dependencies for database and state management. UI Design: clean navigation and readable text. Implemented flashcards and quizzes."},{"heading":"Gamification & Challenges","content":"Streak counter for consecutive correct answers. Progress tracking charts. Categorized vocabulary to avoid overwhelming users. Added encouraging messages and interactive feedback."},{"heading":"Testing & Feedback","content":"Unit tests for core logic. Widget tests for UI. Beta feedback helped refine the quiz logic and user interface."},{"heading":"Future Improvements","content":"Add speech recognition for pronunciation. Expand database with more words and categories. Add competitive multiplayer quizzes. Cloud sync using Firebase."},{"heading":"Conclusion","content":"The German Words App demonstrates how Flutter can be used to create an engaging and effective language-learning tool that helps learners master vocabulary and grammar."}]},{"slug":"voting-system","title":"Planning and Development of the \\"Voting System\\" App","layout":"accordion","sections":[{"heading":"Introduction","content":"The Voting System app was developed as a full-stack application to provide a transparent, secure, and user-friendly way for people to participate in decision-making processes. It allows users to vote on projects or initiatives, and ensures that results are collected and displayed reliably."},{"heading":"Concept & Planning","content":"The main goal was to create an intuitive voting platform with a strong focus on usability, transparency, and scalability. During planning, I defined clear requirements: easy user registration, secure vote handling, result transparency, and an admin area for managing polls."},{"heading":"Target Audience","content":"Organizations, communities, and educational institutions that want to conduct secure and fair voting online."},{"heading":"Core Features","bullets":["User authentication and secure login","Creation and management of polls","Real-time voting and result updates","Transparent display of outcomes","Admin panel for poll and user management"]},{"heading":"Technical Stack & Tools","bullets":["Frontend: Vue.js for a modern and responsive UI","Backend: Spring Boot for reliable server logic","Database: PostgreSQL for storing votes and users","Authentication: JWT (Bearer Token) based authentication for secure API access","Version Control: GitHub"]},{"heading":"App Architecture","bullets":["User Interface: Clean design with Vue.js components","API Layer: RESTful services built with Spring Boot","Database Layer: PostgreSQL with well-structured schemas for users, polls, and results","Security Layer: Keycloak integration for handling roles and permissions"]},{"heading":"Development Process","bullets":["Set up the project repositories (frontend and backend)","Designed database schema for users, polls, and votes","Implemented REST API endpoints in Spring Boot","Built Vue.js components for creating and voting on polls","Implemented JWT (Bearer Token) authentication for secure API access","Tested with sample users and load scenarios"]},{"heading":"Testing & Feedback","content":"I conducted unit and integration tests to ensure correctness of vote handling and data consistency. Beta testers confirmed that the app was intuitive and reliable, which led to small UI improvements and better result visualization."},{"heading":"Conclusion","content":"The Voting System app demonstrates how modern technologies like Vue.js and Spring Boot can be combined to build a secure, scalable, and user-friendly platform for online participation. This project allowed me to strengthen my full-stack development skills and gain practical experience in authentication, backend logic, and UI/UX design."}]},{"slug":"docker-in-practice","title":"Docker in Practice: From Legacy to Modern Microservices","layout":"textlayout","sections":[{"heading":"Docker in Practice: From Legacy to Modern Microservices","content":"After many years in software development, I\'ve learned: The most interesting projects aren\'t the ones where everything is perfect and modern. They\'re the ones where you have to deal with reality – with evolved systems, legacy code, and the challenge of connecting old and new.\\n\\nThis is exactly the world I\'ve been working in for years. And this is where Docker shows its true strength."},{"heading":"The Starting Point: An Evolved Infrastructure","content":"A few years ago, our development landscape still looked traditional:"},{"bullets":["<b>Jenkins</b> as build and deployment tool","Manual setups for development environments","Oracle databases configured differently on each developer\'s machine","Deployments that worked – but often only after several attempts"]},{"content":"That wasn\'t bad. It worked. But it was time-consuming."},{"heading":"The First Docker Experiment: Oracle DB","content":"Our first encounter with Docker was pragmatic: <b>Oracle database for development.</b>\\n\\nPreviously, Oracle setup meant:"},{"bullets":["2-3 hours of installation and configuration","Different versions on different machines","\\"Works on my machine\\" – but not on my colleague\'s"]},{"content":"With Docker:\\n\\n```\\ndocker run oracle-db\\n```\\n\\n10 minutes. Same version everywhere. Reproducible.\\n\\n<b>That was the moment I understood: Docker doesn\'t primarily solve technical problems. It solves human problems.</b>\\n\\nNew developers were productive instead of frustrated. Seniors no longer wasted time on setup support. That alone justified the effort."},{"heading":"The Turning Point: Azure CI/CD and a Complex E-Commerce Architecture","content":"Then came the big step: Migration to Azure DevOps with a fully container-based CI/CD pipeline – and simultaneously the integration of an established e-commerce platform through a development partner."},{"heading":"The Challenge: Hybrid Architecture","content":"Large e-commerce platforms have evolved over years. That also means: <b>Legacy is reality.</b>\\n\\nOur architecture today:"},{"bullets":["<b>An established commerce platform</b> – proven, but with older technologies","<b>PWA Storefront</b> – modern Angular-based Progressive Web App","<b>Modern Microservices</b> – Offer Service, Merchant Service, Product Service","<b>SPA-based Admin Portal</b> – completely modern development"]},{"content":"The interesting part: The PWA looks modern, runs on a modern stack – but still works with the legacy platform in the background. Certain functions like checkout or complex account management are delegated to the established system.\\n\\n<b>This is enterprise reality:</b> Not everything can be rewritten overnight. You have to work with what\'s there."},{"heading":"What Docker Solves Here Specifically","content":""},{"heading":"1. Service Isolation Despite Heterogeneous Technologies","content":"We have services on different tech stacks:"},{"bullets":["Legacy platform (Java-based, older frameworks)","Modern backend services (current Java versions, modern architectures)","Frontend (Angular PWA, Node.js-based)"]},{"content":"Without Docker, every developer would have to install and maintain all these environments locally. With Docker, each service runs in its own container with exactly the dependencies it needs.<br><br><b>Result:</b> A developer can work on the frontend without having Java installed. A backend developer can test different service versions in parallel."},{"heading":"2. CI/CD Pipeline Becomes Consistent and Fast","content":"The switch from Jenkins to Azure DevOps with Docker brought measurable improvements."},{"content":"<b>Before (Jenkins):</b>"},{"bullets":["Build time: 15-25 minutes (depending on service)","Deployment: manual, error-prone","Differences between build environment and production"]},{"content":"<b>Now (Azure + Docker + Helm):</b>"},{"bullets":["Build time: 8-12 minutes for most services","Deployment: automated via Helm Charts","Identical containers from dev to production"]},{"content":"The modern services – Offer Service, Merchant Service, Product Service – run particularly well. They were designed for containers from the start. Short build times, clear dependencies, clean isolation."},{"heading":"3. Helm Charts: Deployment Becomes Declarative","content":"Helm Charts revolutionized deployment. Instead of manual configuration, a YAML file describes the entire deployment:\\n\\n```yaml\\nservice: offer-service\\nversion: 1.2.3\\nreplicas: 3\\nresources: ...\\n```\\n\\nA deployment across multiple environments (Dev, Staging, Production) becomes:"},{"bullets":["Traceable (everything is versioned in Git)","Repeatable (same command, same result)","Safe (rollback possible with one command)"]},{"heading":"4. The Legacy Bridge: Old and New Coexist","content":"Here Docker\'s true strength shows: <b>It enables coexistence.</b><br><br>The legacy platform runs in its containers with its specific requirements. The modern services run in their containers with modern stacks. The PWA communicates with both – transparently through Docker networking.\\n\\nWe don\'t have to rewrite the old platform. We can gradually replace it with modern services – service by service. Docker makes this evolutionary approach practical."},{"heading":"What You Need to Learn (The Critical Points)","content":"After years with Docker in this complex environment, I\'ve also learned: <b>It\'s not a silver bullet.</b>"},{"heading":"1. Performance Differences Are Real","content":"The modern services build quickly and run performantly. But some older services or components are slower.<br><br><b>Why?</b>"},{"bullets":["Large images (sometimes 1-2 GB)","Complex build processes","Many dependencies"]},{"content":"<b>Lesson:</b> Docker doesn\'t make slow software fast. It just makes it reproducibly slow."},{"heading":"2. Debugging Becomes More Complex","content":"When a service doesn\'t work in a container, debugging is more difficult:"},{"bullets":["Logs are distributed across multiple containers","Network issues between containers are subtle","Accessing running containers requires additional steps"]},{"content":"<b>Solution:</b> Good logging and monitoring aren\'t optional. They\'re critical."},{"heading":"3. Image Management Requires Discipline","content":"With Azure Container Registry and many services, we have hundreds of images. Without clear versioning and cleanup strategy, it quickly becomes confusing.<br><br><b>Learnings:</b>"},{"bullets":["Use semantic versioning consistently","Delete old images regularly","Automate security scans"]},{"heading":"4. Not Everything Belongs in Containers","content":"I\'ve also learned: Some components run better outside of containers. Especially with I/O-intensive operations or when external tools need to be integrated.<br><br><b>The question isn\'t:</b> \\"Can I dockerize this?\\"<br><b>The question is:</b> \\"Should I dockerize this?\\""},{"heading":"What I Really Learned","content":"After years in this hybrid world between legacy and modern microservices, my most important insight is:<br><br><b>Docker is an enabler for gradual transformation.</b><br><br>It allows us to:"},{"bullets":["Keep old systems alive while we build new ones","Run different technologies in parallel","Develop and deploy services independently","Let teams work autonomously"]},{"content":"But it doesn\'t replace:"},{"bullets":["Good architecture decisions","Clear documentation","Understanding of your own systems","Disciplined development processes"]},{"content":"The teams that succeed with Docker have understood: <b>Docker is a tool, not an end in itself.</b>"},{"heading":"When Does Docker Make Sense?","content":"Based on this experience, I would recommend Docker for:"},{"bullets":["✓ Microservices architectures – Each service in its container, clear boundaries, independent deployments.","✓ Hybrid environments (Legacy + Modern) – Enables gradual migration without big-bang rewrite.","✓ Teams with multiple developers – Uniform development environments save enormous amounts of time.","✓ CI/CD pipelines – Build once, run anywhere – from local testing to production.","✓ Cloud deployments – Almost all cloud platforms support containers natively."]},{"content":"But be careful with:"},{"bullets":["✗ Very simple projects – A static website doesn\'t need container overhead.","✗ Teams without Docker experience under time pressure – The learning curve is real. Better take time or work classically first.","✗ Legacy monoliths without clear modularization – Putting a monolith in a container doesn\'t solve architecture problems.","✗ Performance-critical applications with high I/O – Container overhead can be noticeable here."]},{"heading":"Looking Forward","content":"These years with Docker in a complex enterprise environment have shaped my perspective on software development.<br><br>I\'ve learned:<br><br><b>Technology must solve problems, not create them.</b><br>Docker solves real problems – when used correctly.<br><br><b>Pragmatism beats purism.</b><br>The perfect architecture on paper is useless. The hybrid solution that works is better.<br><br><b>Evolution beats revolution.</b><br>Complete rewrites are often not possible. But gradual replacement works.<br><br><b>Teams are more important than tools.</b><br>Docker is only as good as the team using it. Without shared understanding, clear standards, and discipline, even Docker becomes a problem."},{"heading":"What This Means for Me","content":"This experience – between legacy and modern microservices, between old and new technologies – has shown me what software development is really about:<br><br><b>Not using the coolest technology, but the right one.</b><br><br>Not rebuilding everything, but <b>working smart with what\'s there.</b><br><br>Not striving for perfection, but <b>continuous improvement.</b><br><br>This is the mindset I bring to future projects.<br><br>Because in the end, it\'s not about containers, microservices, or CI/CD pipelines.<br><br><b>It\'s about building software that solves real problems – pragmatically, sustainably, and with value for the people who work with it.</b>"}]},{"slug":"my-journey-into-ecommerce","title":"My Journey Into E-Commerce and Online Platforms","layout":"textlayout","sections":[{"heading":"My Journey Into E-Commerce and Online Platforms","content":"In April 2019, I relocated to Germany, and after six months of job applications, I joined <b><a href=\\"https://toolineo.de/\\">Toolineo</a></b> as a Java backend developer. It was a new topic and a fresh challenge. Earlier, during my time at <b><a href=\\"https://valoores.com/\\">Valoores</a></b> in Lebanon, I had worked with large retailers such as <b>CVS</b> in the United States and <b>Akey</b> in Russia. These experiences taught me a lot about how businesses operate online and gave me a unique perspective on <b>e-commerce models</b> and the technical decisions that make platforms successful."},{"heading":"What Is E-Commerce?","content":"E-commerce is the art and science of selling products or services online. But it’s not just about putting products on a website—there are several business models, each with its own requirements and technical challenges."},{"heading":"Understanding E-Commerce Models","bullets":["<b>B2C (Business-to-Consumer):</b> Retailers sell directly to consumers. Examples: Toolineo, Amazon, Zalando.","<b>B2B (Business-to-Business):</b> Businesses sell to other businesses. Examples: Toolineo, Alibaba.","<b>C2C (Consumer-to-Consumer):</b> Consumers sell to each other. Examples: eBay, Vinted."]},{"heading":"Key Differences Between B2B and B2C","bullets":["<b>B2B platforms</b> often require bulk ordering, special pricing, and integrations with ERP systems.","<b>B2C platforms</b> focus heavily on user experience, marketing, and fast checkout processes.","<b>Performance & Availability:</b> A slow or unavailable website can kill sales. Platforms must handle traffic spikes and maintain uptime."]},{"heading":"Technical Foundations of E-Commerce","bullets":["<b>CMS Platforms:</b> Shopify, Shopware, Magento. For enterprise-level solutions, development partners often implement <b>Hybris (SAP)</b> or <b>Intershop</b>.","<b>Payment Gateways:</b> Securely process payments and support multiple currencies.","<b>Inventory Management:</b> Synchronize stock, prevent overselling, and automate order processing.","<b>Performance & Availability:</b> Platforms must handle high traffic and maintain uptime to avoid lost revenue."]},{"heading":"Choosing the Right Platform","bullets":["<b>Shopify:</b> Ideal for smaller stores, startups, or businesses that want to launch quickly. It’s easy to use, offers many ready-made integrations, and doesn’t require deep technical expertise. Best for <b>B2C</b> companies focused on brand presentation and fast go-to-market.","<b>Shopware:</b> A flexible and powerful open-source platform popular in Germany and across Europe. Suitable for medium to large businesses that need more customization and control over their infrastructure. Supports both <b>B2C</b> and <b>B2B</b> models and is a great choice for business owners who value <b>creative freedom</b>, <b>European compliance</b>, and <b>scalability</b>.","<b>Intershop:</b> Designed for large enterprises with complex product catalogs, multiple storefronts, and advanced <b>B2B</b> requirements like contract pricing, account management, and ERP integration. Ideal for companies that prioritize <b>robustness</b>, <b>integration depth</b>, and <b>multi-channel sales</b>.","<b>SAP Hybris (SAP Commerce Cloud):</b> Another enterprise-level platform used by global organizations with complex business logic and large-scale operations. Excels in integrating with <b>SAP ERP</b> systems and providing deep personalization and omnichannel capabilities. Best suited for corporations using the <b>SAP ecosystem</b> that need tight integration between e-commerce, logistics, and CRM."]},{"heading":"Real-World Lessons Learned","bullets":["Technical decisions directly impact <b>user experience</b> and <b>operational efficiency</b>.","Choosing the right <b>e-commerce model</b> is as crucial as selecting the platform.","Integrating backend services such as <b>payment processing</b> and <b>inventory management</b> effectively prevents bottlenecks.","Understanding both <b>B2B</b> and <b>B2C</b> models highlights the importance of <b>performance</b>, <b>availability</b>, and <b>scalability</b> for a successful online business."]}]},{"slug":"azure-functions-in-practice","title":"Azure Functions in Practice: Automated Image Processing in E-Commerce","layout":"textlayout","sections":[{"heading":"Azure Functions in Practice: Automated Image Processing in E-Commerce","content":"After many years in software development, I’ve learned: The best technical solutions are often the invisible ones. Serverless computing long sounded like a buzzword to me – until I had a concrete use case where Azure Functions turned out to be exactly the right tool.<br><br>This is the story of how we solved a recurring problem elegantly with a simple serverless function – and what I really learned about serverless along the way."},{"heading":"The Context: E-Commerce and the Image Problem","content":"We’re working on an e-commerce marketplace deployed on Azure. As in any online shop, product images are central to the user experience. But product images have a problem: <b>one image doesn’t fit everywhere.</b>"},{"heading":"The Reality","bullets":["Homepage tiles need small thumbnails (fast loading, overview)","Product listings need medium images (balance between quality and performance)","Product detail pages need large, high-resolution images (zoom, detail)"]},{"content":"Our images first land as originals in <b>Azure Blob Storage</b> – uploaded by merchants, product managers, or via APIs.<br><br><b>The problem:</b> The originals are often 3–5 MB in size. Completely oversized for thumbnails. Disastrous for mobile. A nightmare for page speed."},{"heading":"The Problem: Each image in three sizes – automatically","content":"The requirement was clear:<br><br><b>Each product image must be available in three formats:</b>"},{"bullets":["Thumbnail – small preview","Medium – standard view in listings","Large – high-resolution for detail pages"]},{"content":"Specifically:"},{"bullets":["✅ Automatically for every new image","✅ On every update of existing images","✅ Also for all existing images (migration)"]},{"heading":"Why this isn’t trivial","content":"<b>Option 1: On-the-fly resizing on request</b>"},{"bullets":["Server has to process the image on every request","Performance issue with many simultaneous requests","Caching helps, but the first request is slow"]},{"content":"<b>Option 2: Manual resizing before upload</b>"},{"bullets":["Merchants must upload three versions","Error-prone, inconsistent","Impossible for thousands of existing images"]},{"content":"<b>Option 3: Cronjob on a server</b>"},{"bullets":["Server runs 24/7, even when idle","Polling is inefficient","Delay between upload and availability"]},{"content":"<b>What we needed:</b> A solution that reacts automatically, runs efficiently, and doesn’t cost for idle time."},{"heading":"The Solution: Azure Functions + Blob Storage Trigger","content":"A colleague suggested: <b>Azure Functions with a Blob Storage Trigger.</b>"},{"heading":"The Concept","bullets":["A new image is uploaded to Azure Blob Storage","Blob Storage automatically fires an event","Azure Function is triggered (no polling, no delay)","Python script with ImageMagick processes the image","Three versions are saved back into Blob Storage"]},{"heading":"The Architecture","content":"With Azure Functions:\\n\\n```\\nUpload original image\\n        ↓\\nAzure Blob Storage (Input)\\n        ↓\\n[Blob Trigger fires automatically]\\n        ↓\\nAzure Function (Python + ImageMagick)\\n        ↓\\nProcessing: Thumbnail, Medium, Large\\n        ↓\\nAzure Blob Storage (Output)\\n        ↓\\nThree formats available\\n```\\n\\n<b>A simple but effective architecture – fully automated and without manual intervention.</b>"},{"heading":"Why Azure Functions?","bullets":["<b>Event-driven:</b> No polling required. The function starts automatically when a blob is added or modified.","<b>Serverless:</b> No VM running 24/7. The function exists only while executing. You only pay for the seconds it runs.","<b>Auto-scaling:</b> 100 images uploaded at once? Azure automatically spins up multiple instances in parallel.","<b>Managed infrastructure:</b> Microsoft handles runtime, updates, and availability. We just write code."]},{"heading":"The Technical Implementation","bullets":["<b>Python runtime on Azure Functions:</b> Python was the natural choice – simple, great image-processing libraries, familiar to the team.","<b>ImageMagick:</b> Open-source image processing tool. Can resize, convert, and optimize images. Called via Python.","<b>Blob Trigger:</b> Azure Functions have native integration with Blob Storage. Trigger code is minimal – Azure handles the rest."]},{"heading":"The Corrective Script","content":"The function handled new uploads. But what about <b>thousands of existing images?</b><br><br>We wrote a one-time corrective script that iterates over all images in storage, calls the Azure Function for each (or processes directly). One-time migration, afterwards everything runs automatically."},{"heading":"What Works: Concrete Successes"},{"heading":"1. Automation is completely invisible","content":"<b>That’s the best sign:</b><br><br>No one even thinks about it anymore."},{"bullets":["Merchants upload images → seconds later all three formats are available.","No manual steps.","No waiting time.","No support tickets."]},{"heading":"2. Website performance improved","content":"Before:"},{"bullets":["Homepage loaded 3–5 MB images, even when only thumbnails were shown","Slow load times, especially on mobile","Poor Page Speed Score"]},{"content":"After:"},{"bullets":["Thumbnails: ~50 KB instead of 3 MB","Medium: ~200 KB","Large: Original quality only where needed"]},{"content":"<b>Result:</b> Measurably faster load times, better user experience."},{"heading":"3. Cost Efficiency","content":"Azure Functions pricing is usage-based:"},{"bullets":["You pay per execution and per second of runtime","With moderate upload volume (daily new products, occasional updates), costs remain minimal"]},{"content":"Compared to a VM running 24/7:"},{"bullets":["No idle costs","No maintenance","Automatic scaling without cost planning"]},{"heading":"4. Easy Maintenance","content":"The code is simple. A Python script calling ImageMagick. No complex infrastructure. Changes are quickly deployed."},{"heading":"What to Watch Out For: Critical Points","content":"After months of production use, I’ve also learned: <b>Serverless is not a silver bullet.</b>"},{"heading":"1. Cold start can be noticeable","content":"If the function hasn’t run for a while, Azure needs to spin up a new instance. That takes a few seconds.<br><br><b>In our case:</b> Usually not an issue, since images aren’t processed in real time in front of users. But for interactive use cases (e.g. user uploads an image and wants to see it immediately), cold starts can be annoying.<br><br><b>Solution:</b> Premium plan with “Always On” – but then you pay for idle time."},{"heading":"2. Debugging is harder","content":"When something goes wrong, debugging is more complicated than on a normal server:"},{"bullets":["Logs are scattered across Azure Application Insights.","Local testing requires Azure Functions Core Tools.","Errors are harder to trace."]},{"content":"<b>Lesson:</b> Build good logging from the start. Not afterwards."},{"heading":"3. Vendor Lock-in","content":"Azure Functions are Azure-specific. Migrating code to AWS Lambda requires adjustments. Not impossible, but not trivial.<br><br><b>Trade-off:</b> For us, developer experience and native Azure integration were more important than portability."},{"heading":"4. ImageMagick in Serverless is… special","content":"ImageMagick is an external tool. In Azure Functions, it must be packaged as a dependency. This makes the deployment package larger and slower.<br><br><b>Alternative:</b> Managed services like Azure Cognitive Services for image processing. More expensive, but simpler.<br><br><b>We stuck with ImageMagick:</b> More control, cheaper, and the use case is simple enough."},{"heading":"5. Not suitable for everything","content":"Azure Functions are perfect for:"},{"bullets":["Event-driven tasks","Short-running operations (< 10 minutes)","Unpredictable load"]},{"content":"Azure Functions are NOT good for:"},{"bullets":["Long-running processes (> 10 minutes)","Constant high load (a VM is cheaper)","Very complex state management"]},{"heading":"Learnings: What I Really Took Away","content":"After this experience with serverless, I understood:"},{"heading":"1. Serverless doesn’t mean “no server”","content":"It means: <b>You no longer manage the server.</b><br><br>The infrastructure still exists. You just don’t see it. That’s abstraction, not disappearance."},{"heading":"2. Serverless is an architectural decision","content":"You can’t just make an app “serverless.” Serverless works for <b>specific use cases:</b>"},{"bullets":["Event-driven workflows","Sporadic tasks","Auto-scaling requirements"]},{"content":"But not as a replacement for everything."},{"heading":"3. The ROI is real – when used right","content":"<b>For our use case:</b>"},{"bullets":["No VM maintenance","No idle costs","Automatic scaling","Fast development"]},{"content":"That saves time, money, and complexity."},{"content":"<b>But:</b> For other use cases, a VM or container would have been cheaper and simpler."},{"heading":"4. Start simple, optimize later","content":"Our first version was simple: Python + ImageMagick + Blob Trigger. Done.<br><br>No micro-optimizations. No complex architecture. <b>It worked.</b><br><br>Later, you can optimize (Premium Plan, better caching, alternative libraries). But for the start: <b>Simple is better.</b>"},{"heading":"5. Serverless has become a commodity","content":"Five years ago, serverless was experimental. Today, it’s standard. AWS Lambda, Azure Functions, Google Cloud Functions – all major cloud providers offer it.<br><br><b>This means:</b> It’s no longer a hype. It’s a tool in the toolbox. Not a must-have, but a valid option."},{"heading":"When would I recommend Azure Functions?","content":"After this experience, I’d recommend Azure Functions (or serverless in general) for:"},{"bullets":["<b>✓ Event-driven tasks</b> – Something needs to happen when an event occurs (blob upload, queue message, HTTP request).","<b>✓ Sporadic workloads</b> – Not 24/7, but occasionally – unbeatable serverless cost model.","<b>✓ Prototyping and MVPs</b> – Quickly test an idea without setting up infrastructure.","<b>✓ Glue code between services</b> – Small functions connecting different Azure services.","<b>✓ Auto-scaling needs</b> – Load is unpredictable, serverless scales automatically."]},{"content":"But be careful with:"},{"bullets":["<b>✗ Long-running processes</b> – Azure Functions have timeouts (default: 5 min, max: 10 min). For longer jobs: Azure Batch, Containers, or VMs.","<b>✗ Constant high load</b> – If a function runs 24/7, a VM is cheaper.","<b>✗ Complex state management</b> – Serverless is stateless. For complex workflows: Durable Functions.","<b>✗ Very low-latency requirements</b> – Cold start can be problematic."]},{"heading":"Looking Ahead","content":"This experience with Azure Functions taught me:<br><br><b>Technology should fit the problem, not the other way around.</b><br><br>We had a clear problem: automatically processing images. Azure Functions were perfect for that.<br><br>But I wouldn’t try to build everything with Functions. Some problems need VMs. Some need containers. Some need serverless.<br><br><b>The art lies in choosing the right tool.</b><br><br>This is the mindset I’ve taken from 15 years of development: Don’t chase trends, solve problems. Don’t believe the hype, weigh pros and cons. Don’t aim for perfection – build pragmatic solutions that work.<br><br>Because in the end, it’s not about serverless, microservices, or containers.<br><br><b>It’s about building software that solves real problems – efficiently, maintainably, and with value for the people who use it.</b>"}]},{"slug":"hexagonal-architecture-in-practice","title":"Hexagonal Architecture in Practice: Why Less Changes Than You Think","layout":"textlayout","sections":[{"heading":"Hexagonal Architecture in Practice: Why Less Changes Than You Think","content":"After 15 years in software development, I had an aha moment last week. I read about Hexagonal Architecture, Ports & Adapters, Clean Architecture – and suddenly I realized: <b>We were already doing this 15 years ago. Just with different names.</b><br><br>The frameworks have changed. The buzzwords are new. But the principles? They have stayed the same.<br><br>This insight fundamentally changed my perspective on modern software architecture – and it shows something important: <b>Technology keeps changing, but the principles barely move.</b>"},{"heading":"The Context: Where Did I Come From?","content":""},{"heading":"15 Years Ago: The \'Old\' Java World","content":"When I started programming, the Java enterprise stack was very different:"},{"bullets":["Struts as web framework","Spring for dependency injection (but still with XML configuration)","iBatis (later MyBatis) for database access","JSP for views","Deployment as WAR files on Tomcat or JBoss"]},{"content":"That was the standard. That’s what we learned. That was considered \\"professional\\"."},{"heading":"How We Built Architectures Back Then","content":"We thought in layers:\\n\\n```\\nPresentation Layer\\n  (Struts Actions, JSPs)\\n        ↓\\nBusiness Logic Layer\\n  (Service Classes)\\n        ↓\\nData Access Layer\\n  (DAO Interfaces, iBatis)\\n        ↓\\nDatabase\\n```\\n"},{"content":"<b>Our principles were clear:</b>"},{"bullets":["<b>Separation of Concerns:</b> Each layer has a responsibility","<b>Interfaces everywhere:</b> DAOs were always interfaces","<b>Business logic independent:</b> Service layer knew nothing about HTTP details","<b>Testable:</b> Unit tests for services, mock DAOs for tests"]},{"content":"That was our \\"best practice\\" – long before anyone talked about Hexagonal Architecture."},{"heading":"The Problem: Technology Changes","content":""},{"heading":"Years Passed, New Frameworks Arrived","content":"Over the years, the stack changed dramatically:<br><br><b>2010s:</b>"},{"bullets":["Struts → Spring MVC","XML → Annotations","WAR → Embedded Tomcat"]},{"content":"<b>2020s:</b>"},{"bullets":["Spring Boot as standard","Microservices architectures","Containers (Docker, Kubernetes)","REST APIs instead of JSPs"]},{"content":"<b>And suddenly, new buzzwords:</b>"},{"bullets":["Hexagonal Architecture","Ports & Adapters","Clean Architecture","Domain-Driven Design"]},{"heading":"The Uncertainty","content":"When I heard these new terms, I first thought:<br><br>\\"Is our old architecture outdated? Did we do it wrong? Do we need to relearn everything?\\"<br><br>Conferences full of talks about \\"modern architecture.\\" Books about Clean Code and Domain-Driven Design. YouTube videos about Hexagonal Architecture.<br><br><b>The implicit message:</b> \\"The old is bad, the new is better.\\""},{"heading":"The Solution: Looking Behind the Buzzwords","content":""},{"heading":"The Aha Moment","content":"Last week, I sat with a colleague and we discussed Hexagonal Architecture. He showed me a diagram:\\n\\n```\\nREST Controller (Adapter)\\n        ↓\\nApplication Service (Port)\\n        ↓\\nDomain Logic (Core)\\n        ↓\\nRepository Interface (Port)\\n        ↓\\nRepository Impl (Adapter)\\n```\\n\\nI looked at it – and my jaw dropped.\\n\\n<b>This is exactly what we were doing 15 years ago!</b>"},{"heading":"The Comparison: Then vs. Now","columns":{"damals":"Then (2010)","heute":"Now (2025)","category":"The Principle"},"comparison":[{"category":"Input interface to the outside world","damals":"Struts Action","heute":"REST Controller (Adapter)"},{"category":"Business logic abstraction","damals":"Service Interface + Impl","heute":"Application Service (Port)"},{"category":"Concrete business operations","damals":"Service methods","heute":"Use Cases"},{"category":"Persistence abstraction","damals":"DAO Interface","heute":"Repository Port"},{"category":"Concrete database connection","damals":"iBatis Mapper","heute":"Repository Adapter"}]},{"content":"<b>It’s the same. Only the names have changed.</b>"},{"heading":"What’s Really New (and What Isn’t)","content":"<b>Really new:</b>"},{"bullets":["✅ Syntax: @RestController instead of XML configuration","✅ Tools: Spring Boot vs. Struts + XML","✅ Deployment: Containers vs. WAR files","✅ Terminology: \\"Ports & Adapters\\" vs. \\"DAOs\\""]},{"content":"<b>NOT new:</b>"},{"bullets":["❌ Separation of Concerns","❌ Dependency Inversion","❌ Abstraction via interfaces","❌ Testability through mocking","❌ Loose coupling between layers"]},{"content":"<b>The principles are identical. Only the packaging is more modern.</b>"},{"heading":"1. Separation of Concerns has worked for decades","content":"<b>Back then:</b><br><br>","codeSnippets":["// Struts Action (2010)\\npublic class UserAction extends Action {\\n    private UserService userService; // injected\\n    public ActionForward execute(...) {\\n        User user = userService.findById(id);\\n        request.setAttribute(\\"user\\", user);\\n        return mapping.findForward(\\"success\\");\\n    }\\n}"],"contentAfterCode":""},{"content":"<b>Today:</b><br><br>","codeSnippets":["// REST Controller (2025)\\n@RestController\\npublic class UserController {\\n    private final UserService userService;\\n    @GetMapping(\\"/users/{id}\\")\\n    public User getUser(@PathVariable Long id) {\\n        return userService.findById(id);\\n    }\\n}"],"contentAfterCode":"<b>Difference:</b> Syntax. Principle: The same – Controller delegates to Service."},{"heading":"2. Dependency Inversion has always been smart","content":"<b>Back then:</b><br><br>","codeSnippets":["// Service Layer (2010)\\npublic class UserServiceImpl implements UserService {\\n    private UserDAO userDAO; // Interface!\\n    public User findById(Long id) {\\n        return userDAO.findById(id);\\n    }\\n}"],"contentAfterCode":""},{"content":"<b>Today:</b><br><br>","codeSnippets":["// Application Service (2025)\\n@Service\\npublic class UserService {\\n    private final UserRepository userRepository; // Interface!\\n    public User findById(Long id) {\\n        return userRepository.findById(id);\\n    }\\n}"],"contentAfterCode":"<b>Difference:</b> Annotation. <b>Principle:</b> The same – depends on abstraction, not implementation."},{"heading":"3. Testability through interfaces was always important","content":"<b>Back then:</b><br><br>","codeSnippets":["// Unit Test (2010)\\npublic class UserServiceTest {\\n    @Test\\n    public void testFindById() {\\n        UserDAO mockDAO = mock(UserDAO.class);\\n        when(mockDAO.findById(1L)).thenReturn(testUser);\\n        UserService service = new UserServiceImpl(mockDAO);\\n        User result = service.findById(1L);\\n        assertEquals(\\"John\\", result.getName());\\n    }\\n}"],"contentAfterCode":""},{"content":"<b>Today:</b><br><br>","codeSnippets":["// Unit Test (2025)\\n@Test\\npublic void testFindById() {\\n    UserRepository mockRepo = mock(UserRepository.class);\\n    when(mockRepo.findById(1L)).thenReturn(Optional.of(testUser));\\n    UserService service = new UserService(mockRepo);\\n    User result = service.findById(1L);\\n    assertEquals(\\"John\\", result.getName());\\n}"],"contentAfterCode":"<b>Difference:</b> Minimal. <b>Principle:</b> Exactly the same – mock the dependency, test the logic."},{"heading":"The Insight","content":"<b>We did not build bad architecture.</b><br><br>We applied <b>solid principles</b>:"},{"bullets":["Loose Coupling","Dependency Inversion","Separation of Concerns","Testability"]},{"content":"The industry just <b>repackaged and renamed</b> these principles:"},{"bullets":["\\"DAO\\" → \\"Repository\\"","\\"Service Layer\\" → \\"Application Service\\" / \\"Use Case\\"","\\"Layered Architecture\\" → \\"Hexagonal Architecture\\" / \\"Clean Architecture\\""]},{"content":"<b>The principles were always there. We just found new words for them.</b>"},{"heading":"2. Principles matter more than names","content":"<b>The mistake:</b> Spend hours discussing: \\"Is this a Port or an Adapter?\\"<br><br><b>The reality:</b> The question should be: \\"Is this component testable? Is it decoupled? Is it maintainable?\\"<br><br><b>Names are communication tools, not dogmas.</b>"},{"heading":"3. Distinguishing hype from substance","content":"<b>Frameworks come and go:</b>"},{"bullets":["Struts (dead)","JSF (almost dead)","Spring MVC (standard, but decreasing)","React (current hype)","Next.js (even newer hype)"]},{"content":"Principles remain:"},{"bullets":["SOLID (since 2000, still valid)","Separation of Concerns (since the 1970s)","Dependency Inversion (always)","Testability (always)"]},{"content":"<b>Invest in principles, not in hype.</b>"},{"heading":"4. Old codebases are not automatically bad","content":"<b>The mistake:</b> \\"This code is 10 years old, it must be bad!\\"<br><br>"},{"content":"<b>The reality:</b> If the code is cleanly structured, testable, and works – then it is <b>good</b>, no matter its age.<br><br>"},{"content":"<b>Age ≠ Quality. Structure = Quality.</b>"},{"heading":"Learnings: What I really took away"},{"heading":"1. Frameworks are tools, principles are foundations","content":"<b>As a junior (15 years ago):</b> I thought: \\"Struts is THE way to build web applications.\\"<br><br>"},{"content":"<b>As a senior (today):</b> I know: \\"Struts was ONE tool that helped me apply good principles.\\"<br><br>"},{"content":"<b>The lesson:</b> If you understand the principles (Separation, Decoupling, Testability), you can learn <b>any framework.</b><br><br>If you only memorize frameworks, you are lost when a new one comes."},{"heading":"2. \\"Modern\\" is relative","content":"<b>Modern today:</b><br><br>"},{"bullets":["Hexagonal Architecture","Domain-Driven Design","Microservices","Serverless"]},{"content":"<b>In 10 years:</b><br><br>"},{"bullets":["New buzzwords will exist","Today’s \\"modern\\" frameworks will be legacy","The same principles will still apply"]},{"content":"<b>The lesson:</b> Don’t chase trends. Understand principles."},{"heading":"3. Experience means recognizing patterns","content":"<b>This is the difference between junior and senior:</b><br><br><b>Junior:</b> \\"Hexagonal Architecture is new, I must learn it!\\"<br><br><b>Senior:</b> \\"Hexagonal Architecture? That’s like the DAO pattern with a new name.\\"<br><br><b>The lesson:</b> With experience you see that much repeats – just with different words.<br><br>"},{"heading":"4. Good architecture is timeless","content":"<b>Criteria for good architecture (2010):</b><br><br>"},{"bullets":["Testable","Maintainable","Extensible","Decoupled"]},{"content":"<b>Criteria for good architecture (2025):</b><br><br>"},{"bullets":["Testable","Maintainable","Extensible","Decoupled"]},{"content":"<b>The lesson:</b> These criteria have <b>not changed.</b> And they will not change in 10 years.<br><br>"},{"heading":"5. Humility towards the past","content":"<b>Earlier I thought:</b> \\"The old developers didn’t understand it. We are doing it better today.\\"<br><br><b>Today I know:</b> \\"The old developers understood the same principles. They just had different tools.\\"<br><br><b>The lesson:</b> Respect the work of previous developers. They often did <b>very well</b> – just with different means.<br><br>"},{"heading":"Looking forward"},{"heading":"What does this mean for my work?","content":"This insight fundamentally changed my perspective:<br><br><b>I no longer ask:</b> \\"Is this framework modern?\\"<br><b>I ask:</b> \\"Does this framework help me implement good principles?\\"<br><br><b>I no longer ask:</b> \\"Do we need to migrate to Hexagonal Architecture?\\"<br><b>I ask:</b> \\"Is our architecture testable, maintainable, and decoupled?\\"<br><br><b>I don’t fall for hype anymore.</b><br><b>I focus on timeless principles.</b><br><br>"},{"heading":"What do I recommend to others?"},{"content":"<b>For junior developers:</b><br><br>"},{"bullets":["❌ <b>Not:</b> \\"Memorize Hexagonal Architecture\\"","✅ <b>Better:</b> \\"Understand WHY we separate layers and invert dependencies\\"","❌ <b>Not:</b> \\"Spring Boot is THE solution\\"","✅ <b>Better:</b> \\"Spring Boot is ONE tool that implements principles\\""]},{"content":"<b>If you understand the principles:</b><br><br>"},{"bullets":["You can learn any framework","You can recognize good vs. bad architecture","You are not dependent on trends"]},{"content":"<b>For senior developers:</b><br><br>"},{"bullets":["❌ <b>Not:</b> \\"Our old architecture is outdated\\"","✅ <b>Better:</b> \\"Our architecture follows solid principles – that counts\\"","❌ <b>Not:</b> \\"We must refactor to Hexagonal\\"","✅ <b>Better:</b> \\"Do we have a problem that Hexagonal would solve?\\""]},{"content":"<b>Refactor only with a clear reason, not because of buzzwords.</b><br><br>"},{"heading":"In 15 years"},{"content":"<b>What will change:</b><br><br>"},{"bullets":["Spring Boot may become legacy","New frameworks will exist","New buzzwords will fill conferences","New annotations will be invented"]},{"content":"<b>What will stay the same:</b><br><br>"},{"bullets":["Separation of Concerns will remain important","Testability will matter","Loose Coupling will still apply","Dependency Inversion will work"]},{"content":"<b>As a wise developer once said:</b><br><br>\\"Technology keeps changing, but the principles barely move.\\"<br><br><b>Or even more concisely:</b><br><br>\\"Nothing\'s really new. It just gets a new name, a new annotation, and a new conference talk.\\""},{"heading":"Conclusion: Principles over frameworks"},{"content":"After 15 years in software development, this is my most important insight:<br><br><b>Frameworks are temporary. Principles are eternal.</b><br><br>Struts is dead. iBatis renamed. XML configuration is out.<br><br>But Separation of Concerns? Dependency Inversion? Testability?<br><br><b>They will still matter in 50 years.</b><br><br>This is not nostalgia. This is not resistance to new things.<br><br><b>It is wisdom from experience:</b><br><br>The best developers are not those who follow every new trend.<br>The best developers are those who understand <b>what really matters beneath the surface.</b><br><br>And that is not frameworks.<br><b>That is principles.</b>"}]}]')},410:function(e){e.exports=JSON.parse('[{"slug":"german-nouns","title":"Planung und Entwicklung der Flutter-App \\"German Articles Trainer\\"","layout":"accordion","sections":[{"heading":"Einleitung","content":"Das Lernen deutscher Artikel — der, die, das — ist eine der größten Herausforderungen für Deutschlernende. Artikel folgen nicht immer logischen Regeln, und das Auswendiglernen kann frustrierend sein. Ziel dieser App ist es, das Üben der Artikel einfacher, interaktiver und motivierender zu gestalten."},{"heading":"Konzept & Planung","content":"Von Anfang an wurde die App um drei zentrale Prinzipien entwickelt: Klarheit – Lernende sollen sich nur auf das Wesentliche konzentrieren: Substantive und ihre Artikel. Motivation – Lernkarten, Quizze und Fortschrittsverfolgung halten die Motivation hoch. Zugänglichkeit – Plattformübergreifende Verfügbarkeit (Android und iOS) sorgt für eine breite Reichweite."},{"heading":"Zielgruppe","content":"Anfänger (A1–A2), die die Grundlagen üben möchten. Lernende auf mittlerem Niveau (B1), die ihre Genauigkeit verbessern wollen."},{"heading":"Kernfunktionen","content":"Lernkarten für Artikel. Quizmodus mit sofortigem Feedback. Fortschrittsstatistiken (korrekte/falsche Versuche). Offline-Unterstützung mit lokaler Datenbank."},{"heading":"Technischer Stack & Tools","content":"Sprache & Framework: Dart mit Flutter. UI-Design: Direkt mit Flutter Material Design Widgets umgesetzt. Datenspeicherung: SQLite für Substantive, Artikel und Nutzerfortschritt. State Management: Provider für saubere Zustandsverwaltung. Versionskontrolle: GitHub für Zusammenarbeit und Backup."}]},{"slug":"german-words-app","title":"Planung und Entwicklung der Flutter-App \\"German Words App\\"","layout":"accordion","sections":[{"heading":"Einleitung","content":"Die German Words App hilft Lernenden, Substantive, Verben und Adjektive auf spielerische und interaktive Weise zu üben. Der Fokus liegt auf dem Aufbau von Wortschatz und der Festigung grammatischer Regeln im Kontext."},{"heading":"Konzept & Planung","content":"Die App wurde mit den Prinzipien Klarheit, Motivation und Zugänglichkeit entwickelt. Nutzer können Vokabeln durch Lernkarten, Quizze und interaktive Übungen üben."},{"heading":"Zielgruppe","content":"Anfänger (A1–A2), die grundlegende Wörter lernen, Lernende auf mittlerem Niveau (B1–B2), die ihren Wortschatz erweitern und Grammatik verbessern möchten, und Fortgeschrittene (C1–C2), die nuancierten Wortschatz und idiomatische Ausdrücke meistern wollen."},{"heading":"Niveaus","content":"Die App deckt alle GER-Niveaus ab:\\n\\nA1 – Grundlegende Wörter und Ausdrücke.\\nA2 – Einfache Sätze und Alltagsvokabular.\\nB1 – Mittlerer Wortschatz und Grammatikstrukturen.\\nB2 – Komplexe Sätze, Idiome und erweiterter Wortschatz.\\nC1 – Fortgeschrittener Wortschatz, nuancierte Bedeutungen und fachliche Themen.\\nC2 – Nahezu muttersprachliche Kenntnisse, inklusive idiomatischer Ausdrücke."},{"heading":"Kernfunktionen","content":"Lernkarten für Substantive, Verben und Adjektive. Quizmodus mit sofortigem Feedback. Fortschrittsstatistiken mit Leistungsdiagrammen. Offline-Unterstützung mit lokaler Datenbank."},{"heading":"Technischer Stack & Tools","content":"Flutter mit Dart. Material Design UI. SQLite für lokale Speicherung. Provider für State Management. GitHub für Versionskontrolle."},{"heading":"App-Architektur","content":"Startbildschirm – Navigation zu verschiedenen Übungsmodi. Lernmodus – Karten für Wörter mit korrekten Artikeln/Verben/Adjektiven. Quizmodus – zufällige Fragen. Statistikbildschirm – Übersicht über Fortschritte."},{"heading":"Entwicklungsprozess","content":"Projektsetup: Flutter-Projekt mit Dart SDK. Abhängigkeiten für Datenbank und State Management hinzugefügt. UI-Design: saubere Navigation und lesbarer Text. Lernkarten und Quiz implementiert."},{"heading":"Gamification & Herausforderungen","content":"Streak-Zähler für aufeinanderfolgende richtige Antworten. Fortschrittsdiagramme. Kategorisierte Vokabeln, um Überforderung zu vermeiden. Ermutigende Nachrichten und interaktives Feedback hinzugefügt."},{"heading":"Tests & Feedback","content":"Unit-Tests für Kernlogik. Widget-Tests für die UI. Beta-Feedback half, die Quiz-Logik und die Benutzeroberfläche zu verfeinern."},{"heading":"Zukünftige Verbesserungen","content":"Spracherkennung für Aussprache hinzufügen. Datenbank mit mehr Wörtern und Kategorien erweitern. Wettbewerbsfähige Mehrspieler-Quizze hinzufügen. Cloud-Synchronisation über Firebase."},{"heading":"Fazit","content":"Die German Words App zeigt, wie Flutter genutzt werden kann, um ein ansprechendes und effektives Sprachlernwerkzeug zu erstellen, das Lernenden hilft, Wortschatz und Grammatik zu meistern."}]},{"slug":"voting-system","title":"Planung und Entwicklung der \\"Voting System\\" App","layout":"accordion","sections":[{"heading":"Einleitung","content":"Die Voting System App wurde als Full-Stack-Anwendung entwickelt, um eine transparente, sichere und benutzerfreundliche Möglichkeit zur Teilnahme an Entscheidungsprozessen zu bieten. Nutzer können über Projekte oder Initiativen abstimmen, und die Ergebnisse werden zuverlässig erfasst und angezeigt."},{"heading":"Konzept & Planung","content":"Das Hauptziel war die Erstellung einer intuitiven Voting-Plattform mit Fokus auf Benutzerfreundlichkeit, Transparenz und Skalierbarkeit. Während der Planung wurden klare Anforderungen definiert: einfache Registrierung, sichere Abstimmungsabwicklung, transparente Ergebnisse und ein Adminbereich zur Verwaltung der Umfragen."},{"heading":"Zielgruppe","content":"Organisationen, Gemeinschaften und Bildungseinrichtungen, die sichere und faire Online-Abstimmungen durchführen möchten."},{"heading":"Kernfunktionen","bullets":["Benutzerauthentifizierung und sicherer Login","Erstellung und Verwaltung von Umfragen","Echtzeit-Abstimmung und Ergebnisaktualisierung","Transparente Darstellung der Ergebnisse","Admin-Panel für Umfragen- und Benutzerverwaltung"]},{"heading":"Technischer Stack & Tools","bullets":["Frontend: Vue.js für moderne und responsive UI","Backend: Spring Boot für zuverlässige Serverlogik","Datenbank: PostgreSQL zur Speicherung von Stimmen und Benutzern","Authentifizierung: JWT (Bearer Token) für sicheren API-Zugriff","Versionskontrolle: GitHub"]},{"heading":"App-Architektur","bullets":["Benutzeroberfläche: Sauberes Design mit Vue.js-Komponenten","API-Schicht: RESTful Services mit Spring Boot","Datenbank-Schicht: PostgreSQL mit gut strukturierten Schemata für Nutzer, Umfragen und Ergebnisse","Sicherheitsschicht: Keycloak-Integration zur Rollen- und Berechtigungsverwaltung"]},{"heading":"Entwicklungsprozess","bullets":["Projekt-Repositorys (Frontend und Backend) eingerichtet","Datenbankschema für Nutzer, Umfragen und Stimmen entworfen","REST API-Endpunkte in Spring Boot implementiert","Vue.js-Komponenten für Erstellung und Abstimmung von Umfragen erstellt","JWT-Authentifizierung für sicheren API-Zugriff implementiert","Tests mit Beispielbenutzern und Lastszenarien durchgeführt"]},{"heading":"Tests & Feedback","content":"Ich führte Unit- und Integrationstests durch, um die korrekte Verarbeitung der Stimmen und Datenkonsistenz sicherzustellen. Beta-Tester bestätigten, dass die App intuitiv und zuverlässig ist, was zu kleineren UI-Verbesserungen und besserer Ergebnisvisualisierung führte."},{"heading":"Fazit","content":"Die Voting System App zeigt, wie moderne Technologien wie Vue.js und Spring Boot kombiniert werden können, um eine sichere, skalierbare und benutzerfreundliche Plattform für Online-Teilnahme zu entwickeln. Dieses Projekt ermöglichte mir, meine Full-Stack-Fähigkeiten zu stärken und praktische Erfahrungen in Authentifizierung, Backend-Logik und UI/UX-Design zu sammeln."}]},{"slug":"docker-in-der-praxis","title":"Docker in der Praxis: Von Legacy zu modernen Microservices","layout":"textlayout","sections":[{"heading":"Docker in der Praxis: Von Legacy zu modernen Microservices","content":"Nach vielen Jahren in der Softwareentwicklung habe ich gelernt: Die interessantesten Projekte sind nicht die, wo alles perfekt und modern ist. Es sind die, wo man mit der Realität umgehen muss – mit gewachsenen Systemen, Legacy-Code und der Herausforderung, Altes und Neues miteinander zu verbinden.\\n\\nGenau in so einer Welt arbeite ich seit Jahren. Und genau hier zeigt Docker seine wahre Stärke."},{"heading":"Der Ausgangspunkt: Eine gewachsene Infrastruktur","content":"Vor einigen Jahren sah unsere Entwicklungslandschaft noch klassisch aus:"},{"bullets":["<b>Jenkins</b> als Build- und Deployment-Tool","Manuelle Setups für Entwicklungsumgebungen","Oracle-Datenbanken, die auf jedem Entwicklerrechner anders konfiguriert waren","Deployments, die funktionierten – aber oft nur nach mehreren Versuchen"]},{"content":"Das war nicht schlecht. Es hat funktioniert. Aber es war aufwändig."},{"heading":"Das erste Docker-Experiment: Oracle DB","content":"Unser erster Berührungspunkt mit Docker war pragmatisch: <b>Oracle-Datenbank für die Entwicklung.</b>\\n\\nVorher bedeutete Oracle-Setup:"},{"bullets":["2-3 Stunden Installation und Konfiguration","Unterschiedliche Versionen auf verschiedenen Rechnern","\\"Bei mir läuft\'s\\" – beim Kollegen nicht"]},{"content":"Mit Docker:\\n\\n```\\ndocker run oracle-db\\n```\\n\\n10 Minuten. Gleiche Version überall. Reproduzierbar.\\n\\n<b>Das war der Moment, wo ich verstanden habe: Docker löst nicht primär technische Probleme. Es löst menschliche Probleme.</b>\\n\\nNeue Entwickler waren produktiv, statt frustriert. Seniors verloren keine Zeit mehr mit Setup-Support. Das allein rechtfertigte den Aufwand."},{"heading":"Der Wendepunkt: Azure CI/CD und eine komplexe E-Commerce-Architektur","content":"Dann kam der große Schritt: Migration zu Azure DevOps mit einer vollständig containerbasierten CI/CD-Pipeline – und gleichzeitig die Integration einer etablierten E-Commerce-Plattform durch einen Entwicklungspartner."},{"heading":"Die Herausforderung: Hybrid-Architektur","content":"Große E-Commerce-Plattformen sind über Jahre gewachsen. Das bedeutet auch: <b>Legacy ist Realität.</b>\\n\\nUnsere Architektur heute:"},{"bullets":["<b>Eine etablierte Commerce-Plattform</b> – bewährt, aber mit älteren Technologien","<b>PWA Storefront</b> – moderne Angular-basierte Progressive Web App","<b>Moderne Microservices</b> – Angebots-Service, Händler-Service, Produkt-Service","<b>SPA-basiertes Admin-Portal</b> – komplett modern entwickelt"]},{"content":"Das Interessante: Die PWA sieht modern aus, läuft auf modernem Stack – aber arbeitet im Hintergrund teilweise noch mit der Legacy-Plattform zusammen. Bestimmte Funktionen wie Checkout oder komplexe Account-Verwaltung werden an das etablierte System delegiert.\\n\\n<b>Das ist Enterprise-Realität:</b> Nicht alles kann über Nacht neu geschrieben werden. Man muss mit dem arbeiten, was da ist."},{"heading":"Was Docker hier konkret löst","content":""},{"heading":"1. Service-Isolation trotz heterogener Technologien","content":"Wir haben Services auf unterschiedlichen Tech-Stacks:"},{"bullets":["Legacy-Plattform (Java-basiert, ältere Frameworks)","Moderne Backend-Services (aktuelle Java-Versionen, moderne Architekturen)","Frontend (Angular PWA, Node.js-basiert)"]},{"content":"Ohne Docker müsste jeder Entwickler alle diese Umgebungen lokal installieren und pflegen. Mit Docker läuft jeder Service in seinem eigenen Container mit genau den Dependencies, die er braucht.<br><br><b>Ergebnis:</b> Ein Entwickler kann am Frontend arbeiten, ohne Java installiert zu haben. Ein Backend-Entwickler kann verschiedene Service-Versionen parallel testen."},{"heading":"2. CI/CD-Pipeline wird konsistent und schnell","content":"Der Wechsel von Jenkins zu Azure DevOps mit Docker brachte messbare Verbesserungen."},{"content":"<b>Vorher (Jenkins):</b>"},{"bullets":["Build-Zeit: 15-25 Minuten (je nach Service)","Deployment: manuell, fehleranfällig","Unterschiede zwischen Build-Umgebung und Production"]},{"content":"<b>Jetzt (Azure + Docker + Helm):</b>"},{"bullets":["Build-Zeit: 8-12 Minuten für die meisten Services","Deployment: automatisiert via Helm Charts","Identische Container von Dev bis Production"]},{"content":"Die modernen Services – Angebots-Service, Händler-Service, Produkt-Service – laufen besonders gut. Sie wurden von Anfang an für Container designed. Kurze Build-Zeiten, klare Dependencies, saubere Isolation."},{"heading":"3. Helm Charts: Deployment wird deklarativ","content":"Helm Charts haben das Deployment revolutioniert. Statt manueller Konfiguration beschreibt eine YAML-Datei das gesamte Deployment:\\n\\n```yaml\\nservice: offer-service\\nversion: 1.2.3\\nreplicas: 3\\nresources: ...\\n```\\n\\nEin Deployment über mehrere Umgebungen (Dev, Staging, Production) wird dadurch:"},{"bullets":["Nachvollziehbar (alles ist in Git versioniert)","Wiederholbar (gleicher Befehl, gleiches Ergebnis)","Sicher (Rollback mit einem Befehl möglich)"]},{"heading":"4. Die Legacy-Bridge: Alt und Neu koexistieren","content":"Hier zeigt sich die wahre Stärke von Docker: <b>Es ermöglicht Koexistenz.</b><br><br>Die Legacy-Plattform läuft in ihren Containern mit ihren spezifischen Anforderungen. Die modernen Services laufen in ihren Containern mit modernen Stacks. Die PWA kommuniziert mit beiden – transparent durch Docker-Networking.\\n\\nWir müssen die alte Plattform nicht neu schreiben. Wir können sie schrittweise durch moderne Services ersetzen – Service für Service. Docker macht diesen evolutionären Ansatz praktikabel."},{"heading":"Was man dabei lernen muss (die kritischen Punkte)","content":"Nach Jahren mit Docker in dieser komplexen Umgebung habe ich auch gelernt: <b>Es ist kein Allheilmittel.</b>"},{"heading":"1. Performance-Unterschiede sind real","content":"Die modernen Services bauen schnell und laufen performant. Aber manche ältere Services oder Komponenten sind langsamer.<br><br><b>Warum?</b>"},{"bullets":["Große Images (manchmal 1-2 GB)","Komplexe Build-Prozesse","Viele Dependencies"]},{"content":"<b>Lektion:</b> Docker macht langsame Software nicht schnell. Es macht sie nur reproduzierbar langsam."},{"heading":"2. Debugging wird komplexer","content":"Wenn ein Service im Container nicht funktioniert, ist Debugging schwieriger:"},{"bullets":["Logs sind über mehrere Container verteilt","Netzwerk-Probleme zwischen Containern sind subtil","Der Zugriff auf laufende Container erfordert zusätzliche Schritte"]},{"content":"<b>Lösung:</b> Gutes Logging und Monitoring sind nicht optional. Sie sind kritisch."},{"heading":"3. Image-Management braucht Disziplin","content":"Mit Azure Container Registry und vielen Services haben wir hunderte Images. Ohne klare Versionierung und Cleanup-Strategie wird es schnell unübersichtlich.<br><br><b>Learnings:<b>"},{"bullets":["Semantic Versioning konsequent nutzen","Alte Images regelmäßig löschen","Security-Scans automatisieren"]},{"heading":"4. Nicht alles gehört in Container","content":"Ich habe auch gelernt: Manche Komponenten laufen besser außerhalb von Containern. Besonders bei I/O-intensiven Operationen oder wenn externe Tools integriert werden müssen.<br><br><b>Die Frage ist nicht:</b> \\"Kann ich das dockern?\\"<br><b>Die Frage ist:</b> \\"Sollte ich das dockern?\\""},{"heading":"Was ich wirklich gelernt habe","content":"Nach Jahren in dieser Hybrid-Welt zwischen Legacy und modernen Microservices ist meine wichtigste Erkenntnis:<br><br><b>Docker ist ein Enabler für schrittweise Transformation.</b><br><br>Es erlaubt uns:"},{"bullets":["Alte Systeme am Leben zu halten, während wir neue bauen","Verschiedene Technologien parallel zu betreiben","Services unabhängig voneinander zu entwickeln und zu deployen","Teams autonom arbeiten zu lassen"]},{"content":"Aber es ersetzt nicht:"},{"bullets":["Gute Architektur-Entscheidungen","Klare Dokumentation","Verständnis der eigenen Systeme","Disziplinierte Entwicklungsprozesse"]},{"content":"Die Teams, die mit Docker erfolgreich sind, haben verstanden: <b>Docker ist ein Werkzeug, kein Selbstzweck.</b>"},{"heading":"Wann macht Docker Sinn?","content":"Nach dieser Erfahrung würde ich Docker empfehlen für:"},{"bullets":["✓ Microservices-Architekturen – Jeder Service in seinem Container, klare Grenzen, unabhängige Deployments.","✓ Hybrid-Umgebungen (Legacy + Modern) – Ermöglicht schrittweise Migration ohne Big-Bang-Rewrite.","✓ Teams mit mehreren Entwicklern – Einheitliche Entwicklungsumgebungen sparen enorm viel Zeit.","✓ CI/CD-Pipelines – Build once, run anywhere – vom lokalen Test bis Production.","✓ Cloud-Deployments – Fast alle Cloud-Plattformen unterstützen Container nativ."]},{"content":"Aber Vorsicht bei:"},{"bullets":["✗ Sehr einfachen Projekten – Eine statische Website braucht keinen Container-Overhead.","✗ Teams ohne Docker-Erfahrung unter Zeitdruck – Die Lernkurve ist real. Lieber Zeit nehmen oder erstmal klassisch arbeiten.","✗ Legacy-Monolithen ohne klare Modularisierung – Einen Monolithen in einen Container zu packen löst keine Architektur-Probleme.","✗ Performance-kritische Anwendungen mit hohem I/O – Der Container-Overhead kann hier spürbar sein."]},{"heading":"Der Blick nach vorne","content":"Diese Jahre mit Docker in einer komplexen Enterprise-Umgebung haben meine Perspektive auf Softwareentwicklung geprägt.<br><br>Ich habe gelernt:<br><br><b>Technologie muss Probleme lösen, nicht schaffen.</b>  <br>Docker löst echte Probleme – wenn man es richtig einsetzt.<br><br><b>Pragmatismus schlägt Purismus.</b>  <br>Die perfekte Architektur auf dem Papier nützt nichts. Die Hybrid-Lösung, die funktioniert, ist besser.<br><br><b>Evolution schlägt Revolution.</b>  <br>Komplette Neuentwicklungen sind oft nicht möglich. Aber schrittweiser Ersatz funktioniert.<br><br><b>Teams sind wichtiger als Tools.</b>  <br>Docker ist nur so gut wie das Team, das es einsetzt. Ohne gemeinsames Verständnis, klare Standards und Disziplin wird auch Docker zum Problem."},{"heading":"Was das für mich bedeutet","content":"Diese Erfahrung – zwischen Legacy und modernen Microservices, zwischen alten und neuen Technologien – hat mir gezeigt, worum es in der Softwareentwicklung wirklich geht:<br><br><b>Nicht die coolste Technologie zu verwenden, sondern die richtige.</b><br><br>Nicht alles neu zu bauen, sondern <b>smart mit dem zu arbeiten, was da ist.</b><br><br>Nicht Perfektion anzustreben, sondern <b>kontinuierliche Verbesserung.</b><br><br>Das ist die Denkweise, die ich in zukünftige Projekte mitbringe.<br><br>Denn am Ende geht es nicht um Container, Microservices oder CI/CD-Pipelines.<br><br><b>Es geht darum, Software zu bauen, die echte Probleme löst – pragmatisch, nachhaltig und mit Mehrwert für die Menschen, die damit arbeiten.</b>"}]},{"slug":"mein-weg-in-den-e-commerce","title":"Mein Weg in den E-Commerce und zu Online-Plattformen","layout":"textlayout","sections":[{"heading":"Mein Weg in den E-Commerce und zu Online-Plattformen","content":"Im April 2019 zog ich nach Deutschland und trat nach sechs Monaten Bewerbungszeit bei <b><a href=\\"https://toolineo.de/\\">Toolineo</a></b> als Java-Backend-Entwickler ein. Es war ein neues Thema und eine spannende Herausforderung. Zuvor hatte ich während meiner Zeit bei <b><a href=\\"https://valoores.com/\\">Valoores</a></b> im Libanon mit großen Einzelhändlern wie <b>CVS</b> in den USA und <b>Akey</b> in Russland zusammengearbeitet. Diese Erfahrungen lehrten mich viel darüber, wie Unternehmen online agieren, und gaben mir eine einzigartige Perspektive auf <b>E-Commerce-Modelle</b> und die technischen Entscheidungen, die Plattformen erfolgreich machen."},{"heading":"Was ist E-Commerce?","content":"E-Commerce ist die Kunst und Wissenschaft, Produkte oder Dienstleistungen online zu verkaufen. Doch es geht nicht nur darum, Produkte auf eine Website zu stellen – es gibt verschiedene Geschäftsmodelle, jedes mit eigenen Anforderungen und technischen Herausforderungen."},{"heading":"E-Commerce-Modelle verstehen","bullets":["<b>B2C (Business-to-Consumer):</b> Einzelhändler verkaufen direkt an Endkunden. Beispiele: Toolineo, Amazon, Zalando.","<b>B2B (Business-to-Business):</b> Unternehmen verkaufen an andere Unternehmen. Beispiele: Toolineo, Alibaba.","<b>C2C (Consumer-to-Consumer):</b> Privatpersonen verkaufen an andere Privatpersonen. Beispiele: eBay, Vinted."]},{"heading":"Wichtige Unterschiede zwischen B2B und B2C","bullets":["<b>B2B-Plattformen</b> erfordern oft Großbestellungen, spezielle Preisgestaltung und Integrationen mit ERP-Systemen.","<b>B2C-Plattformen</b> konzentrieren sich stark auf Benutzererlebnis, Marketing und einen schnellen Checkout-Prozess.","<b>Performance & Verfügbarkeit:</b> Eine langsame oder nicht erreichbare Website kann den Umsatz sofort beeinträchtigen. Plattformen müssen Lastspitzen bewältigen und eine hohe Verfügbarkeit sicherstellen."]},{"heading":"Technische Grundlagen des E-Commerce","bullets":["<b>CMS-Plattformen:</b> Shopify, Shopware, Magento. Für Enterprise-Lösungen werden häufig <b>Hybris (SAP)</b> oder <b>Intershop</b> eingesetzt.","<b>Zahlungssysteme:</b> Sichere Abwicklung von Zahlungen und Unterstützung mehrerer Währungen.","<b>Lagerverwaltung:</b> Bestände synchronisieren, Überverkäufe vermeiden und Bestellprozesse automatisieren.","<b>Performance & Verfügbarkeit:</b> Plattformen müssen hohen Traffic bewältigen und Ausfallzeiten vermeiden, um Umsatzeinbußen zu verhindern."]},{"heading":"Die richtige Plattform wählen","content":"Die Wahl der richtigen Plattform ist genauso wichtig wie die Wahl des passenden E-Commerce-Modells. Jede Plattform richtet sich an unterschiedliche Geschäftsgrößen und Anforderungen. Hier ist, was ich gelernt habe:","bullets":["<b>Shopify:</b> Ideal für kleinere Geschäfte, Start-ups oder Unternehmen, die schnell starten möchten. Es ist einfach zu bedienen, bietet viele fertige Integrationen und erfordert keine tiefgehenden technischen Kenntnisse. Am besten geeignet für <b>B2C</b>-Unternehmen, die Wert auf Markenpräsentation und einen schnellen Markteintritt legen.","<b>Shopware:</b> Eine flexible und leistungsstarke Open-Source-Plattform, die besonders in Deutschland und Europa beliebt ist. Geeignet für mittlere bis große Unternehmen, die mehr Anpassung und Kontrolle über ihre Infrastruktur benötigen. Unterstützt sowohl <b>B2C</b>- als auch <b>B2B</b>-Modelle und ist ideal für Unternehmer, die <b>kreative Freiheit</b>, <b>europäische Rechtskonformität</b> und <b>Skalierbarkeit</b> schätzen.","<b>Intershop:</b> Entwickelt für große Unternehmen mit komplexen Produktkatalogen, mehreren Shops und fortgeschrittenen <b>B2B</b>-Anforderungen wie Vertrags-Preisen, Kundenkonten und ERP-Integration. Ideal für Firmen, die <b>Robustheit</b>, <b>tiefe Integrationen</b> und <b>Multi-Channel-Vertrieb</b> benötigen.","<b>SAP Hybris (SAP Commerce Cloud):</b> Eine weitere Enterprise-Plattform, die von globalen Unternehmen mit komplexer Geschäftslogik, internationalen Märkten und großen Datenmengen genutzt wird. Hervorragend geeignet für die Integration mit <b>SAP ERP</b>-Systemen und bietet starke Personalisierungs- und Omnichannel-Funktionen. Am besten geeignet für Konzerne, die bereits das <b>SAP-Ökosystem</b> nutzen und eine enge Verzahnung zwischen E-Commerce, Logistik und CRM benötigen."]},{"heading":"Erkenntnisse aus der Praxis","bullets":["Technische Entscheidungen haben direkten Einfluss auf <b>Benutzererlebnis</b> und <b>operative Effizienz</b>.","Die Wahl des richtigen <b>E-Commerce-Modells</b> ist ebenso entscheidend wie die Wahl der Plattform.","Eine effektive Integration von Backend-Diensten wie <b>Zahlungsabwicklung</b> und <b>Lagerverwaltung</b> verhindert Engpässe.","Das Verständnis beider Modelle – <b>B2B</b> und <b>B2C</b> – zeigt, wie wichtig <b>Performance</b>, <b>Verfügbarkeit</b> und <b>Skalierbarkeit</b> für den Erfolg eines Online-Geschäfts sind."]}]},{"slug":"azure-functions-in-practice","title":"Azure Functions in der Praxis: Automatische Bildverarbeitung im E-Commerce","layout":"textlayout","sections":[{"heading":"Azure Functions in der Praxis: Automatische Bildverarbeitung im E-Commerce","content":"Nach vielen Jahren in der Softwareentwicklung habe ich gelernt: Die besten technischen Lösungen sind oft die unsichtbaren. Serverless Computing klang für mich lange nach Buzzword und Hype. Bis ich einen konkreten Use Case hatte, bei dem Azure Functions genau das richtige Werkzeug waren.\\n\\nDies ist die Geschichte, wie wir mit einer einfachen serverless Function ein wiederkehrendes Problem elegant gelöst haben – und was ich dabei über Serverless wirklich gelernt habe."},{"heading":"Der Kontext: E-Commerce und das Bildproblem","content":"Wir arbeiten an einem E-Commerce-Marktplatz, der auf Azure deployed ist. Wie in jedem Online-Shop sind Produktbilder zentral für die User Experience. Aber Produktbilder haben ein Problem:<b> Ein Bild passt nicht überall.</b>"},{"heading":"Die Realität","bullets":["Homepage-Kacheln brauchen kleine Thumbnails (schnell laden, Übersicht)","Produktlisten brauchen mittlere Bilder (Balance zwischen Qualität und Performance)","Produktdetailseiten brauchen große, hochauflösende Bilder (Zoom, Details)"]},{"content":"Unsere Bilder landen zunächst als Originale im <b>Azure Blob Storage</b> – hochgeladen von Händlern, Produktmanagern oder über APIs. <br><br><b>Das Problem:</b> Die Originale sind oft 3-5 MB groß. Für Thumbnails völlig überdimensioniert. Für Mobile katastrophal. Für Page Speed ein Desaster."},{"heading":"Das Problem: Jedes Bild in drei Größen – automatisch","content":"Die Anforderung war klar: <br><br><b>Jedes Produktbild muss in drei Formaten verfügbar sein:</b>"},{"bullets":["Thumbnail – kleine Vorschau","Medium – Standardansicht in Listen","Large – hochauflösend für Detailseiten"]},{"content":"Und zwar:"},{"bullets":["✅ Automatisch bei jedem neuen Bild","✅ Bei jeder Änderung an existierenden Bildern","✅ Auch für alle bereits existierenden Bilder (Migration)"]},{"heading":"Warum das nicht trivial ist","content":"<b>Option 1: On-the-fly Resizing beim Abruf</b>"},{"bullets":["Server muss bei jedem Request das Bild verarbeiten","Performance-Problem bei vielen gleichzeitigen Anfragen","Cache hilft, aber erster Request ist langsam"]},{"content":"<b>Option 2: Manuell vor Upload</b>"},{"bullets":["Händler müssen 3 Versionen hochladen","Fehleranfällig, inkonsistent","Unmöglich für bereits existierende Tausende von Bildern"]},{"content":"<b>Option 3: Cronjob auf einem Server</b>"},{"bullets":["Server läuft 24/7, auch wenn nichts zu tun ist","Polling ineffizient","Verzögerung zwischen Upload und Verfügbarkeit"]},{"content":"<b>Was wir brauchten:</b> Eine Lösung, die automatisch reagiert, effizient läuft und nicht für Idle-Zeit kostet."},{"heading":"Die Lösung: Azure Functions + Blob Storage Trigger","content":"Ein Kollege schlug vor: <b>Azure Functions mit Blob Storage Trigger.</b>"},{"heading":"Das Konzept","bullets":["Neues Bild wird in Azure Blob Storage hochgeladen","Blob Storage feuert automatisch einen Event","Azure Function wird getriggert (ohne Polling, ohne Delay)","Python-Skript mit ImageMagick verarbeitet das Bild","Drei Versionen werden zurück in Blob Storage gespeichert"]},{"heading":"Die Architektur","content":"Mit Azure Functions:\\n\\n```\\nOriginal-Bild hochladen\\n        ↓\\nAzure Blob Storage (Input)\\n        ↓\\n[Blob Trigger feuert automatisch]\\n        ↓\\nAzure Function (Python + ImageMagick)\\n        ↓\\nVerarbeitung: Thumbnail, Medium, Large\\n        ↓\\nAzure Blob Storage (Output)\\n        ↓\\nDrei Formate verfügbar\\n```\\n\\n<b>Eine einfache, aber effektive Architektur – komplett automatisch und ohne manuelles Eingreifen.</b>"},{"heading":"Warum Azure Functions?","bullets":["<b>Event-driven:</b> Kein Polling nötig. Die Function startet automatisch, wenn ein Blob hinzugefügt oder geändert wird.","<b>Serverless:</b> Keine VM, die 24/7 läuft. Die Function existiert nur während der Ausführung. Du zahlst nur für die Sekunden, in denen sie läuft.","<b>Auto-Scaling:</b> Kommen 100 Bilder gleichzeitig? Azure startet automatisch mehrere Instanzen parallel.","<b>Managed Infrastructure:</b> Microsoft kümmert sich um Runtime, Updates, Verfügbarkeit. Wir schreiben nur Code."]},{"heading":"Die technische Umsetzung","bullets":["<b>Python Runtime auf Azure Functions:</b> Python war die natürliche Wahl – einfach, gute Libraries für Bildverarbeitung, vom Team bekannt.","<b>ImageMagick:</b> Open-Source Bildverarbeitungs-Tool. Kann Bilder skalieren, konvertieren, optimieren. Wird über Python aufgerufen.","<b>Blob Trigger:</b> Azure Functions haben native Integration mit Blob Storage. Der Trigger-Code ist minimal – Azure macht den Rest."]},{"heading":"Das Corrective Script","content":"Die Function löste neue Uploads. Aber was ist mit den <b>Tausenden bereits existierenden Bildern?</b><br><br>Dafür haben wir ein einmaliges Corrective Script geschrieben, das alle Bilder im Storage durchläuft, für jedes die Azure Function aufruft (oder direkt verarbeitet). Einmalige Migration, danach läuft alles automatisch."},{"heading":"Was funktioniert: Konkrete Erfolge"},{"heading":"1. Automatisierung ist komplett unsichtbar","content":"<b>Das ist das beste Zeichen:</b><br><br>Niemand denkt mehr darüber nach."},{"bullets":["Händler laden Bilder hoch → Sekunden später sind alle drei Formate verfügbar.","Kein manueller Schritt.","Keine Wartezeit.","Kein Support-Ticket."]},{"heading":"2. Performance der Website verbessert","content":"Vorher:"},{"bullets":["Homepage lud 3-5 MB Bilder, auch wenn nur Thumbnails angezeigt wurden","Langsame Ladezeiten, besonders auf Mobile","Schlechter Page Speed Score"]},{"content":"Nachher:"},{"bullets":["Thumbnails: ~50 KB statt 3 MB","Medium: ~200 KB","Large: Original-Qualität nur wo nötig"]},{"content":"<b>Ergebnis:.</b> Messbar schnellere Ladezeiten, bessere User Experience"},{"heading":"3. Kosteneffizienz","content":"Azure Functions Pricing ist nutzungsbasiert:"},{"bullets":["Du zahlst pro Ausführung und pro Sekunde Laufzeit","Bei moderatem Upload-Volumen (täglich neue Produkte, gelegentliche Updates) sind die Kosten minimal"]},{"content":"Im Vergleich zu einer VM, die 24/7 läuft:"},{"bullets":["Keine Idle-Kosten","Keine Wartung","Automatisches Scaling ohne Mehrkosten-Planung"]},{"heading":"4. Einfache Wartung","content":"Der Code ist simpel. Ein Python-Skript, das ImageMagick aufruft. Keine komplexe Infrastruktur. Änderungen sind schnell deployed."},{"heading":"Was man beachten muss: Kritische Punkte","content":"Nach Monaten mit dieser Lösung im Einsatz habe ich auch gelernt: <b>Serverless ist kein Allheilmittel</b>"},{"heading":"1. Cold Start kann spürbar sein","content":"Wenn die Function längere Zeit nicht gelaufen ist, muss Azure eine neue Instanz starten. Das dauert ein paar Sekunden.<br><br><b>Bei uns:</b> Meist kein Problem, weil Bilder nicht in Echtzeit vor den Augen des Users verarbeitet werden. Aber bei interaktiven Use Cases (z.B. User lädt Bild hoch und will es sofort sehen) kann Cold Start nerven.<br><br><b>Lösung:</b> Premium Plan mit \\"Always On\\" – aber dann zahlst du wieder für Idle-Time."},{"heading":"2. Debugging ist schwieriger","content":"Läuft etwas schief, ist Debugging komplizierter als auf einem normalen Server:"},{"bullets":["Logs sind in Azure Application Insights verstreut.","Lokales Testen braucht Azure Functions Core Tools.","Fehler sind schwerer nachzuvollziehen."]},{"content":"<b>Lektion:</b> Gutes Logging von Anfang an einbauen. Nicht nachträglich."},{"heading":"3. Vendor Lock-in","content":"Azure Functions sind Azure-spezifisch. Code auf AWS Lambda zu migrieren bedeutet Anpassungen. Nicht unmöglich, aber auch nicht trivial.<br><br><b>Abwägung:</b> Für uns war die Developer Experience und native Azure-Integration wichtiger als Portabilität."},{"heading":"4. ImageMagick in Serverless ist... speziell","content":"ImageMagick ist ein externes Tool. In Azure Functions muss es als Dependency mitgepackt werden. Das macht das Deployment-Package größer und langsamer.<br><br><b>Alternative:</b> Managed Services wie Azure Cognitive Services für Bildverarbeitung. Teurer, aber einfacher.<br><br><b>Wir haben bei ImageMagick geblieben:</b> Mehr Kontrolle, günstiger, Use Case ist einfach genug."},{"heading":"5. Nicht für alles geeignet","content":"Azure Functions sind perfekt für:"},{"bullets":["Event-driven Tasks","Kurzlaufende Operationen (< 10 Minuten)","Unvorhersehbare Last"]},{"content":"Azure Functions sind NICHT gut für:"},{"bullets":["Langläufige Prozesse (> 10 Minuten)","Konstant hohe Last (dann ist eine VM günstiger)","Sehr komplexes State Management"]},{"heading":"Learnings: Was ich wirklich mitgenommen habe","content":"Nach dieser Erfahrung mit Serverless habe ich verstanden:"},{"heading":"1. Serverless heißt nicht \\"kein Server\\"","content":"Es heißt: <b>Du managst den Server nicht mehr.</b><br><br>Die Infrastruktur existiert noch. Du siehst sie nur nicht. Das ist Abstraktion, kein Verschwinden."},{"heading":"2. Serverless ist Architektur-Entscheidung","content":"Man kann nicht einfach eine Anwendung \\"serverless machen\\". Serverless funktioniert für <b>spezifische Use Cases:</b>"},{"bullets":["Event-driven Workflows","Sporadische Tasks","Auto-Scaling-Bedarf"]},{"content":"Aber nicht als Ersatz für alles."},{"heading":"3. Der ROI ist real – bei richtigem Einsatz","content":"<b>Für unseren Use Case:</b>"},{"bullets":["Keine Wartung einer VM","Keine Idle-Kosten","Automatisches Scaling","Schnelle Entwicklung"]},{"content":"Das spart Zeit, Geld und Komplexität."},{"content":"<b>Aber:</b> Für andere Use Cases wäre eine VM oder Container günstiger und einfacher gewesen."},{"heading":"4. Start simple, optimize later","content":"Unsere erste Version war simpel: Python + ImageMagick + Blob Trigger. Fertig.<br><br>Keine Micro-Optimierungen. Keine komplexe Architektur. <b>Es hat funktioniert.</b><br><br>Später kann man optimieren (Premium Plan, bessere Caching, alternative Libraries). Aber für den Start: <b>Simple is better.</b>"},{"heading":"5. Serverless ist Commodity geworden","content":"Vor 5 Jahren war Serverless experimentell. Heute ist es Standard. AWS Lambda, Azure Functions, Google Cloud Functions – alle großen Cloud-Anbieter haben es.<br><br><b>Das bedeutet:</b> Es ist nicht mehr Hype. Es ist ein Werkzeug im Toolbelt. Kein Muss, aber eine valide Option."},{"heading":"Wann würde ich Azure Functions empfehlen?","content":"Nach dieser Erfahrung würde ich Azure Functions (oder generell Serverless) empfehlen für:"},{"bullets":["<b>✓ Event-driven Tasks</b> – Etwas muss passieren, wenn ein Event eintritt (Blob hochgeladen, Queue-Message, HTTP-Request).","<b>✓ Sporadische Workloads</b> – Nicht 24/7, sondern gelegentlich – Serverless-Kosten unschlagbar.","<b>✓ Prototyping und MVPs</b> – Schnell eine Idee testen, ohne Infrastruktur aufzusetzen.","<b>✓ Glue Code zwischen Services</b> – Kleine Funktionen, die verschiedene Azure-Services verbinden.","<b>✓ Auto-Scaling-Bedarf</b> – Last ist unvorhersehbar, Serverless skaliert automatisch."]},{"content":"Aber Vorsicht bei:"},{"bullets":["<b>✗ Langläufigen Prozessen</b> – Azure Functions haben Timeouts (Standard: 5 Min, max: 10 Min). Für längere Jobs: Azure Batch, Container, VMs.","<b>✗ Konstant hoher Last</b> – Wenn Function 24/7 läuft, VM günstiger.","<b>✗ Komplexem State Management</b> – Serverless ist stateless. Für komplexe Workflows: Durable Functions.","<b>✗ Sehr niedrigen Latenz-Anforderungen</b> – Cold Start kann problematisch sein."]},{"heading":"Der Blick nach vorne","content":"Diese Erfahrung mit Azure Functions hat mir gezeigt:<br><br><b>Technologie sollte zum Problem passen, nicht umgekehrt.</b><br><br>Wir hatten ein klares Problem: Bilder automatisch verarbeiten. Azure Functions waren dafür perfekt.<br><br>Aber ich würde nicht versuchen, alles in Functions zu packen. Manche Probleme brauchen VMs. Manche Container. Manche Serverless.<br><br><b>Die Kunst liegt darin, das richtige Werkzeug zu wählen.</b><br><br>Das ist die Denkweise, die ich aus 15 Jahren Entwicklung mitnehme: Nicht Trends folgen, sondern Probleme lösen. Nicht Hype glauben, sondern Vor- und Nachteile abwägen. Nicht Perfektion anstreben, sondern pragmatische Lösungen bauen, die funktionieren.<br><br>Denn am Ende geht es nicht um Serverless, Microservices oder Container.<br><br><b>Es geht darum, Software zu bauen, die echte Probleme löst – effizient, wartbar und mit Mehrwert für die Menschen, die damit arbeiten.</b>"}]},{"slug":"hexagonal-architecture-in-practice","title":"Hexagonal Architecture in der Praxis: Warum sich weniger ändert, als man denkt","layout":"textlayout","sections":[{"heading":"Hexagonal Architecture in der Praxis: Warum sich weniger ändert, als man denkt","content":"Nach 15 Jahren in der Softwareentwicklung hatte ich letzte Woche einen Aha-Moment. Ich las über Hexagonal Architecture, Ports & Adapters, Clean Architecture – und plötzlich wurde mir klar: <b>Das haben wir vor 15 Jahren auch schon gemacht. Nur mit anderen Namen.</b><br><br>Die Frameworks haben sich geändert. Die Buzzwords sind neu. Aber die Prinzipien? Die sind die gleichen geblieben.<br><br>Diese Erkenntnis hat meine Perspektive auf moderne Software-Architektur grundlegend verändert – und sie zeigt etwas Wichtiges: <b>Technology keeps changing, but the principles barely move.</b>"},{"heading":"Der Kontext: Wo kam ich her?","content":""},{"heading":"Vor 15 Jahren: Die \\"alte\\" Java-Welt","content":"Als ich anfing zu programmieren, war der Java-Enterprise-Stack noch ganz anders:"},{"bullets":["Struts als Web-Framework","Spring für Dependency Injection (aber noch mit XML-Konfiguration)","iBatis (später MyBatis) für Datenbank-Zugriff","JSP für Views","Deployment als WAR-Files auf Tomcat oder JBoss"]},{"content":"Das war der Standard. Das haben wir gelernt. Das galt als \\"professionell\\"."},{"heading":"Wie wir damals Architekturen gebaut haben","content":"Wir haben in Schichten gedacht:\\n\\n```\\nPresentation Layer\\n  (Struts Actions, JSPs)\\n        ↓\\nBusiness Logic Layer\\n  (Service Classes)\\n        ↓\\nData Access Layer\\n  (DAO Interfaces, iBatis)\\n        ↓\\nDatabase\\n```\\n"},{"content":"<b>Unsere Prinzipien waren klar:</b>"},{"bullets":["<b>Separation of Concerns:</b> Jede Schicht hat eine Aufgabe","<b>Interfaces überall:</b> DAOs waren immer Interfaces","<b>Business Logic unabhängig:</b> Service-Layer kannte keine HTTP-Details","<b>Testbar:</b> Unit Tests für Services, Mock-DAOs für Tests"]},{"content":"Das war unsere \\"Best Practice\\" – lange bevor jemand von Hexagonal Architecture sprach."},{"heading":"Das Problem: Der Wandel der Technologie","content":""},{"heading":"Die Jahre vergingen, neue Frameworks kamen","content":"Über die Jahre hat sich der Stack dramatisch verändert:<br><br><b>2010er Jahre:</b>"},{"bullets":["Struts → Spring MVC","XML → Annotations","WAR → Embedded Tomcat"]},{"content":"<b>2020er Jahre:</b>"},{"bullets":["Spring Boot als Standard","Microservices-Architekturen","Container (Docker, Kubernetes)","REST APIs statt JSPs"]},{"content":"<b>Und plötzlich neue Buzzwords:</b>"},{"bullets":["Hexagonal Architecture","Ports & Adapters","Clean Architecture","Domain-Driven Design"]},{"heading":"Die Verunsicherung","content":"Als ich diese neuen Begriffe hörte, dachte ich zunächst:<br><br>\\"Ist unsere alte Architektur veraltet? Haben wir es falsch gemacht? Müssen wir alles neu lernen?\\"<br><br>Konferenzen voller Talks über \\"moderne Architektur\\". Bücher über Clean Code und Domain-Driven Design. YouTube-Videos über Hexagonal Architecture.<br><br><b>Die implizite Botschaft:</b> \\"Das Alte ist schlecht, das Neue ist besser.\\""},{"heading":"Die Lösung: Der Blick hinter die Buzzwords","content":""},{"heading":"Der Aha-Moment","content":"Letzte Woche saß ich mit einem Kollegen zusammen und wir diskutierten über Hexagonal Architecture. Er zeigte mir ein Diagramm:\\n\\n```\\nREST Controller (Adapter)\\n        ↓\\nApplication Service (Port)\\n        ↓\\nDomain Logic (Core)\\n        ↓\\nRepository Interface (Port)\\n        ↓\\nRepository Impl (Adapter)\\n```\\n\\nIch schaute es an – und mir fiel die Kinnlade runter.\\n\\n<b>Das ist exakt das, was wir vor 15 Jahren auch gemacht haben!</b>"},{"heading":"Der Vergleich: Damals vs. Heute","columns":{"damals":"Damals (2010)","heute":"Heute (2025)","category":"Das Prinzip"},"comparison":[{"category":"Eingangs-Schnittstelle zur Außenwelt","damals":"Struts Action","heute":"REST Controller (Adapter)"},{"category":"Business-Logik-Abstraktion","damals":"Service Interface + Impl","heute":"Application Service (Port)"},{"category":"Konkrete Business-Operationen","damals":"Service-Methoden","heute":"Use Cases"},{"category":"Persistenz-Abstraktion","damals":"DAO Interface","heute":"Repository Port"},{"category":"Konkrete Datenbankanbindung","damals":"iBatis Mapper","heute":"Repository Adapter"}]},{"content":"<b>Es ist das Gleiche. Nur die Namen haben sich geändert.</b>"},{"heading":"Was wirklich neu ist (und was nicht)","content":"<b>Wirklich neu:</b>"},{"bullets":["✅ Syntax: @RestController statt XML-Konfiguration","✅ Tools: Spring Boot vs. Struts + XML","✅ Deployment: Container vs. WAR-Files","✅ Terminologie: \\"Ports & Adapters\\" vs. \\"DAOs\\""]},{"content":"<b>NICHT neu:</b>"},{"bullets":["❌ Separation of Concerns","❌ Dependency Inversion","❌ Abstraktion über Interfaces","❌ Testability durch Mocking","❌ Lose Kopplung zwischen Schichten"]},{"content":"<b>Die Prinzipien sind identisch. Nur die Verpackung ist moderner.</b>"},{"heading":"1. Separation of Concerns funktioniert seit Jahrzehnten","content":"<b>Damals:</b><br><br>","codeSnippets":["// Struts Action (2010)\\npublic class UserAction extends Action {\\n    private UserService userService; // injected\\n    public ActionForward execute(...) {\\n        User user = userService.findById(id);\\n        request.setAttribute(\\"user\\", user);\\n        return mapping.findForward(\\"success\\");\\n    }\\n}"],"contentAfterCode":""},{"content":"<b>Heute:</b><br><br>","codeSnippets":["// REST Controller (2025)\\n@RestController\\npublic class UserController {\\n    private final UserService userService;\\n    @GetMapping(\\"/users/{id}\\")\\n    public User getUser(@PathVariable Long id) {\\n        return userService.findById(id);\\n    }\\n}"],"contentAfterCode":"<b>Unterschied:</b> Syntax. Prinzip: Das Gleiche – Controller delegiert an Service."},{"heading":"2. Dependency Inversion war schon immer klug","content":"<b>Damals:</b><br><br>","codeSnippets":["// Service Layer (2010)\\npublic class UserServiceImpl implements UserService {\\n    private UserDAO userDAO; // Interface!\\n    public User findById(Long id) {\\n        return userDAO.findById(id);\\n    }\\n}"],"contentAfterCode":""},{"content":"<b>Heute:</b><br><br>","codeSnippets":["// Application Service (2025)\\n@Service\\npublic class UserService {\\n    private final UserRepository userRepository; // Interface!\\n    public User findById(Long id) {\\n        return userRepository.findById(id);\\n    }\\n}"],"contentAfterCode":"<b>Unterschied:</b> Annotation. <b>Prinzip:</b> Das Gleiche – abhängig von Abstraktion, nicht Implementierung."},{"heading":"3. Testability durch Interfaces war immer wichtig","content":"<b>Damals:</b><br><br>","codeSnippets":["// Unit Test (2010)\\npublic class UserServiceTest {\\n    @Test\\n    public void testFindById() {\\n        UserDAO mockDAO = mock(UserDAO.class);\\n        when(mockDAO.findById(1L)).thenReturn(testUser);\\n        UserService service = new UserServiceImpl(mockDAO);\\n        User result = service.findById(1L);\\n        assertEquals(\\"John\\", result.getName());\\n    }\\n}"],"contentAfterCode":""},{"content":"<b>Heute:</b><br><br>","codeSnippets":["// Unit Test (2025)\\n@Test\\npublic void testFindById() {\\n    UserRepository mockRepo = mock(UserRepository.class);\\n    when(mockRepo.findById(1L)).thenReturn(Optional.of(testUser));\\n    UserService service = new UserService(mockRepo);\\n    User result = service.findById(1L);\\n    assertEquals(\\"John\\", result.getName());\\n}"],"contentAfterCode":"<b>Unterschied:</b> Minimal. <b>Prinzip:</b> Exakt das Gleiche – Mock die Abhängigkeit, teste die Logik."},{"heading":"Die Erkenntnis","content":"<b>Wir haben keine schlechte Architektur gebaut.</b><br><br>Wir haben <b>solide Prinzipien</b> angewendet:"},{"bullets":["Loose Coupling","Dependency Inversion","Separation of Concerns","Testability"]},{"content":"Die Industrie hat diese Prinzipien nur <b>neu verpackt und umbenannt:</b>"},{"bullets":["\\"DAO\\" → \\"Repository\\"","\\"Service Layer\\" → \\"Application Service\\" / \\"Use Case\\"","\\"Layered Architecture\\" → \\"Hexagonal Architecture\\" / \\"Clean Architecture\\""]},{"content":"<b>Die Prinzipien waren immer da. Wir haben nur neue Worte dafür gefunden.</b>"},{"heading":"2. Prinzipien wichtiger als Namen","content":"<b>Der Fehler:</b> Stunden damit verbringen, zu diskutieren: \\"Ist das jetzt ein Port oder ein Adapter?\\"<br><br><b>Die Realität:</b> Die Frage sollte sein: \\"Ist diese Komponente testbar? Ist sie entkoppelt? Ist sie wartbar?\\"<br><br><b>Namen sind Kommunikationsmittel, keine Dogmen.</b>"},{"heading":"3. Hype vs. Substanz unterscheiden","content":"<b>Frameworks kommen und gehen:</b>"},{"bullets":["Struts (tot)","JSF (fast tot)","Spring MVC (Standard, aber wird weniger)","React (aktuell Hype)","Next.js (noch neuerer Hype)"]},{"content":"Prinzipien bleiben:"},{"bullets":["SOLID (seit 2000, immer noch gültig)","Separation of Concerns (seit 1970er)","Dependency Inversion (seit immer)","Testability (seit immer)"]},{"content":"<b>Investiere in Prinzipien, nicht in Hype.</b>"},{"heading":"4. Alte Code-Basen sind nicht automatisch schlecht","content":"<b>Der Fehler:</b> \\"Dieser Code ist 10 Jahre alt, der muss schlecht sein!\\"<br><br>"},{"content":"<b>Die Realität:</b> Wenn der Code sauber strukturiert ist, testbar ist und funktioniert – dann ist er <b>gut</b>, egal wie alt.<br><br>"},{"content":"<b>Alter ≠ Qualität. Struktur = Qualität.</b>"},{"heading":"Learnings: Was ich wirklich mitgenommen habe"},{"heading":"1. Frameworks sind Werkzeuge, Prinzipien sind Fundamente","content":"<b>Als Junior (vor 15 Jahren):</b> Ich dachte: \\"Struts ist DIE Art, Web-Anwendungen zu bauen.\\"<br><br>"},{"content":"<b>Als Senior (heute):</b> Ich weiß: \\"Struts war EIN Werkzeug, das mir half, gute Prinzipien anzuwenden.\\"<br><br>"},{"content":"<b>Die Lektion:</b> Wenn du die Prinzipien verstehst (Separation, Decoupling, Testability), kannst du <b>jedes Framework lernen.</b><br><br>Wenn du nur Frameworks auswendig lernst, bist du verloren, sobald ein neues kommt."},{"heading":"2. \\"Modern\\" ist relativ","content":"<b>Heute modern:</b><br><br>"},{"bullets":["Hexagonal Architecture","Domain-Driven Design","Microservices","Serverless"]},{"content":"<b>In 10 Jahren:</b><br><br>"},{"bullets":["Werden neue Buzzwords existieren","Werden heutige \\"moderne\\" Frameworks Legacy sein","Werden die gleichen Prinzipien immer noch gelten"]},{"content":"<b>Die Lektion:</b> Jage nicht Trends. Verstehe Prinzipien."},{"heading":"3. Erfahrung bedeutet Muster erkennen","content":"<b>Das ist der Unterschied zwischen Junior und Senior:</b><br><br><b>Junior:</b> \\"Hexagonal Architecture ist neu, ich muss es lernen!\\"<br><br><b>Senior:</b> \\"Hexagonal Architecture? Das ist wie DAO-Pattern mit neuem Namen.\\"<br><br><b>Die Lektion:</b> Mit Erfahrung siehst du, dass sich vieles wiederholt – nur mit anderen Worten.<br><br>"},{"heading":"4. Gute Architektur ist zeitlos","content":"<b>Kriterien für gute Architektur (2010):</b><br><br>"},{"bullets":["Testbar","Wartbar","Erweiterbar","Entkoppelt"]},{"content":"<b>Kriterien für gute Architektur (2025):</b><br><br>"},{"bullets":["Testbar","Wartbar","Erweiterbar","Entkoppelt"]},{"content":"<b>Die Lektion:</b> Diese Kriterien haben sich <b>nicht geändert.</b> Und sie werden sich auch in 10 Jahren nicht ändern.<br><br>"},{"heading":"5. Bescheidenheit gegenüber der Vergangenheit","content":"<b>Früher dachte ich:</b> \\"Die alten Entwickler haben es nicht verstanden. Wir machen es heute besser.\\"<br><br><b>Heute weiß ich:</b> \\"Die alten Entwickler haben die gleichen Prinzipien verstanden. Sie hatten nur andere Tools.\\"<br><br><b>Die Lektion:</b> Respekt vor der Arbeit früherer Entwickler. Sie haben oft <b>sehr gut</b> gearbeitet – nur mit anderen Mitteln.<br><br>"},{"heading":"Der Blick nach vorne"},{"heading":"Was bedeutet das für meine Arbeit?","content":"Diese Erkenntnis hat meine Perspektive fundamental verändert:<br><br><b>Ich frage nicht mehr:</b> \\"Ist dieses Framework modern?\\"<br><b>Ich frage:</b> \\"Hilft mir dieses Framework, gute Prinzipien umzusetzen?\\"<br><br><b>Ich frage nicht mehr:</b> \\"Müssen wir zu Hexagonal Architecture migrieren?\\"<br><b>Ich frage:</b> \\"Ist unsere Architektur testbar, wartbar und entkoppelt?\\"<br><br><b>Ich falle nicht mehr auf Hype rein.</b><br><b>Ich fokussiere mich auf zeitlose Prinzipien.</b><br><br>"},{"heading":"Was empfehle ich anderen?"},{"content":"<b>Für Junior-Entwickler:</b><br><br>"},{"bullets":["❌ <b>Nicht:</b> \\"Lerne Hexagonal Architecture auswendig\\"","✅ <b>Besser:</b> \\"Verstehe, WARUM wir Schichten trennen und Abhängigkeiten umkehren\\"","❌ <b>Nicht:</b> \\"Spring Boot ist DIE Lösung\\"","✅ <b>Besser:</b> \\"Spring Boot ist EIN Werkzeug, das Prinzipien umsetzt\\""]},{"content":"<b>Wenn du die Prinzipien verstehst:</b><br><br>"},{"bullets":["Kannst du jedes Framework lernen","Erkennst du gute vs. schlechte Architektur","Bist du nicht abhängig von Trends"]},{"content":"<b>Für Senior-Entwickler:</b><br><br>"},{"bullets":["❌ <b>Nicht:</b> \\"Unsere alte Architektur ist veraltet\\"","✅ <b>Besser:</b> \\"Unsere Architektur folgt soliden Prinzipien – das zählt\\"","❌ <b>Nicht:</b> \\"Wir müssen auf Hexagonal refactoren\\"","✅ <b>Besser:</b> \\"Haben wir ein Problem, das Hexagonal lösen würde?\\""]},{"content":"<b>Refactore nur mit klarem Grund, nicht wegen Buzzwords.</b><br><br>"},{"heading":"In 15 Jahren"},{"content":"<b>Was wird anders sein:</b><br><br>"},{"bullets":["Spring Boot wird vielleicht Legacy sein","Neue Frameworks werden existieren","Neue Buzzwords werden Konferenzen füllen","Neue Annotations werden erfunden"]},{"content":"<b>Was gleich bleiben wird:</b><br><br>"},{"bullets":["Separation of Concerns wird wichtig sein","Testability wird zählen","Loose Coupling wird gelten","Dependency Inversion wird funktionieren"]},{"content":"<b>Denn wie ein kluger Entwickler mal sagte:</b><br><br>\\"Technology keeps changing, but the principles barely move.\\"<br><br><b>Oder noch prägnanter:</b><br><br>\\"Nothing\'s really new. It just gets a new name, a new annotation, and a new conference talk.\\""},{"heading":"Fazit: Prinzipien über Frameworks"},{"content":"Nach 15 Jahren in der Softwareentwicklung ist das meine wichtigste Erkenntnis:<br><br><b>Frameworks sind temporär. Prinzipien sind ewig.</b><br><br>Struts ist tot. iBatis ist umbenannt. XML-Konfiguration ist out.<br><br>Aber Separation of Concerns? Dependency Inversion? Testability?<br><br><b>Die werden noch in 50 Jahren gelten.</b><br><br>Das ist nicht Nostalgie. Das ist nicht Widerstand gegen Neues.<br><br><b>Es ist Weisheit aus Erfahrung:</b><br><br>Die besten Entwickler sind nicht die, die jeden neuen Trend mitgehen.<br>Die besten Entwickler sind die, die verstehen, <b>was unter der Oberfläche wirklich zählt.</b><br><br>Und das sind nicht Frameworks.<br><b>Das sind Prinzipien.</b>"}]}]')},411:function(e,n,t){"use strict";t(365)},412:function(e,n,t){var r=t(61)(function(i){return i[1]});r.push([e.i,".project-title[data-v-42ccd3fa]{font-size:2rem;font-weight:600;line-height:1.3;margin-bottom:2rem;text-align:center}",""]),r.locals={},e.exports=r},415:function(e,n,t){"use strict";t.r(n);var r=t(124),o=t(6),l=(t(54),t(45),t(103),t(15),t(38),{props:{sections:{type:Array,required:!0}},data:function(){return{activeIndex:0}},computed:{normalizedSections:function(){return(this.sections||[]).map(function(section){return{title:section.title||section.heading||"No Title",content:section.content||"",bullets:section.bullets||null}})}},methods:{toggle:function(e){this.activeIndex=this.activeIndex===e?null:e}}}),c=(t(403),t(405),t(21)),d=Object(c.a)(l,function(){var e=this,n=e._self._c;return n("div",{staticClass:"accordion"},e._l(e.normalizedSections,function(t,r){return n("div",{key:r,staticClass:"accordion-item"},[n("div",{staticClass:"accordion-header",class:{active:e.activeIndex===r},on:{click:function(n){return e.toggle(r)}}},[e._v("\n      "+e._s(t.title)+"\n      "),n("span",{staticClass:"arrow",class:{open:e.activeIndex===r}},[e._v("▼")])]),e._v(" "),n("transition",{attrs:{name:"accordion"}},[n("div",{directives:[{name:"show",rawName:"v-show",value:e.activeIndex===r,expression:"activeIndex === index"}],staticClass:"accordion-content"},[t.bullets?n("ul",e._l(t.bullets,function(t,i){return n("li",{key:i},[e._v(e._s(t))])}),0):n("p",[e._v(e._s(t.content))])])])],1)}),0)},[],!1,null,"1e4061e5",null).exports,h=(t(34),t(24),t(64),t(170),t(354),t(35),{name:"TextLayout",props:{sections:{type:Array,required:!0}},methods:{parseContent:function(content){var e=content.split(/```([\s\S]*?)```/g),n=[];return e.forEach(function(text,i){if(i%2==1)n.push({type:"code",text:text.trim()});else{var e=text.split("\n").map(function(e){return e.trim()}).filter(Boolean).filter(function(e){return/^(\d+\.|\-)\s/.test(e)});if(e.length){var t=e.map(function(e){return e.replace(/^(\d+\.|\-)\s/,"")});n.push({type:"list",items:t})}else n.push({type:"text",text:text.trim()})}}),n},parseInlineCode:function(text){return text.replace(/`([^`]+)`/g,'<code class="inline-code">$1</code>')}}}),m=(t(407),Object(c.a)(h,function(){var e=this,n=e._self._c;return n("div",{staticClass:"text-layout"},e._l(e.sections,function(section,t){return n("article",{key:t,staticClass:"text-section"},[section.heading||section.title?n("h2",{staticClass:"section-title"},[e._v("\n      "+e._s(section.heading||section.title)+"\n    ")]):e._e(),e._v(" "),section.bullets?n("ul",{staticClass:"section-bullets"},e._l(section.bullets,function(t,i){return n("li",{key:i,domProps:{innerHTML:e._s(e.parseInlineCode(t))}})}),0):section.comparison?n("div",[n("table",{staticClass:"hidden md:table w-full border-collapse"},[n("thead",[n("tr",{staticClass:"bg-gray-100"},[n("th",{staticClass:"p-2 border text-red-600"},[e._v(e._s(section.columns.damals))]),e._v(" "),n("th",{staticClass:"p-2 border text-green-600"},[e._v(e._s(section.columns.heute))]),e._v(" "),n("th",{staticClass:"p-2 border text-indigo-600"},[e._v(e._s(section.columns.category))])])]),e._v(" "),n("tbody",e._l(section.comparison,function(t,i){return n("tr",{key:i,staticClass:"hover:bg-gray-50"},[n("td",{staticClass:"p-2 border bg-red-50 text-gray-800"},[e._v(e._s(t.damals))]),e._v(" "),n("td",{staticClass:"p-2 border bg-green-50 text-gray-800"},[e._v(e._s(t.heute))]),e._v(" "),n("td",{staticClass:"p-2 border bg-gray-50 text-gray-800"},[e._v(e._s(t.category))])])}),0)])]):section.content?n("div",e._l(e.parseContent(section.content),function(t,i){return n("div",{key:i},["code"===t.type?n("pre",{staticClass:"section-code"},[n("code",[e._v(e._s(t.text))])]):"list"===t.type?n("ul",{staticClass:"section-bullets"},e._l(t.items,function(t,r){return n("li",{key:r,domProps:{innerHTML:e._s(e.parseInlineCode(t))}})}),0):n("p",{staticClass:"section-content",domProps:{innerHTML:e._s(e.parseInlineCode(t.text))}})])}),0):e._e(),e._v(" "),section.codeSnippets&&section.codeSnippets.length?n("div",{staticClass:"mt-4"},[n("h3",{staticClass:"font-semibold text-gray-700 mb-2"},[e._v("Code Snippets")]),e._v(" "),e._l(section.codeSnippets,function(t,i){return n("div",{key:i,staticClass:"section-code"},[n("pre",[n("code",[e._v(e._s(t))])])])}),e._v(" "),section.contentAfterCode?n("div",{staticClass:"mt-2",domProps:{innerHTML:e._s(section.contentAfterCode)}}):e._e()],2):e._e()])}),0)},[],!1,null,"8732a564",null).exports),f=t(171),v=t(409),k=t(172),w=t(410),y={name:"ProjectPage",layout:"blog_layout",components:{AccordionLayout:d,TextLayout:m},head:function(){var e;return{title:(null===(e=this.project)||void 0===e?void 0:e.title)||"Jalal El Saddi"}},asyncData:function(e){return Object(o.a)(regeneratorRuntime.mark(function n(){var t,o,l,c,d;return regeneratorRuntime.wrap(function(n){for(;;)switch(n.prev=n.next){case 0:return t=e.params,o=e.app,l=o.i18n?o.i18n.locale:"en",c="de"===l?[].concat(Object(r.a)(k),Object(r.a)(w)):[].concat(Object(r.a)(f),Object(r.a)(v)),d=c.find(function(p){return p.slug===t.slug}),n.abrupt("return",{project:d});case 1:case"end":return n.stop()}},n)}))()},computed:{componentType:function(){var e,n;if(!this.project)return null;switch(null===(e=this.project.layout)||void 0===e||null===(n=e.toLowerCase)||void 0===n?void 0:n.call(e)){case"accordion":return"AccordionLayout";case"text":case"structured":return"TextLayout";default:return this.project.accordion?"AccordionLayout":this.project.sections?"TextLayout":null}},componentProps:function(){return this.project?{sections:this.project.sections||this.project.accordion||[]}:{}}}},A=(t(411),Object(c.a)(y,function(){var e=this,n=e._self._c;return n("main",{staticClass:"container flex-grow-1",staticStyle:{"padding-top":"8rem","padding-bottom":"5.5rem"}},[n("h1",{staticClass:"project-title"},[e._v(e._s(e.project.title))]),e._v(" "),e.componentType?n(e.componentType,e._b({tag:"component"},"component",e.componentProps,!1)):e._e()],1)},[],!1,null,"42ccd3fa",null));n.default=A.exports}}]);