__NUXT_JSONP__("/de/projects/hexagonal-architecture-in-practice", (function(a,b,c,d,e,f,g,h,i,j){return {data:[{project:{slug:"hexagonal-architecture-in-practice",title:d,layout:"textlayout",sections:[{heading:d,content:"Nach 15 Jahren in der Softwareentwicklung hatte ich letzte Woche einen Aha-Moment. Ich las über Hexagonal Architecture, Ports & Adapters, Clean Architecture – und plötzlich wurde mir klar: \u003Cb\u003EDas haben wir vor 15 Jahren auch schon gemacht. Nur mit anderen Namen.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003EDie Frameworks haben sich geändert. Die Buzzwords sind neu. Aber die Prinzipien? Die sind die gleichen geblieben.\u003Cbr\u003E\u003Cbr\u003EDiese Erkenntnis hat meine Perspektive auf moderne Software-Architektur grundlegend verändert – und sie zeigt etwas Wichtiges: \u003Cb\u003ETechnology keeps changing, but the principles barely move.\u003C\u002Fb\u003E"},{heading:"Der Kontext: Wo kam ich her?",content:a},{heading:"Vor 15 Jahren: Die \"alte\" Java-Welt",content:"Als ich anfing zu programmieren, war der Java-Enterprise-Stack noch ganz anders:"},{bullets:["Struts als Web-Framework","Spring für Dependency Injection (aber noch mit XML-Konfiguration)","iBatis (später MyBatis) für Datenbank-Zugriff","JSP für Views","Deployment als WAR-Files auf Tomcat oder JBoss"]},{content:"Das war der Standard. Das haben wir gelernt. Das galt als \"professionell\"."},{heading:"Wie wir damals Architekturen gebaut haben",content:"Wir haben in Schichten gedacht:\n\n```\nPresentation Layer\n  (Struts Actions, JSPs)\n        ↓\nBusiness Logic Layer\n  (Service Classes)\n        ↓\nData Access Layer\n  (DAO Interfaces, iBatis)\n        ↓\nDatabase\n```\n"},{content:"\u003Cb\u003EUnsere Prinzipien waren klar:\u003C\u002Fb\u003E"},{bullets:["\u003Cb\u003ESeparation of Concerns:\u003C\u002Fb\u003E Jede Schicht hat eine Aufgabe","\u003Cb\u003EInterfaces überall:\u003C\u002Fb\u003E DAOs waren immer Interfaces","\u003Cb\u003EBusiness Logic unabhängig:\u003C\u002Fb\u003E Service-Layer kannte keine HTTP-Details","\u003Cb\u003ETestbar:\u003C\u002Fb\u003E Unit Tests für Services, Mock-DAOs für Tests"]},{content:"Das war unsere \"Best Practice\" – lange bevor jemand von Hexagonal Architecture sprach."},{heading:"Das Problem: Der Wandel der Technologie",content:a},{heading:"Die Jahre vergingen, neue Frameworks kamen",content:"Über die Jahre hat sich der Stack dramatisch verändert:\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003E2010er Jahre:\u003C\u002Fb\u003E"},{bullets:["Struts → Spring MVC","XML → Annotations","WAR → Embedded Tomcat"]},{content:"\u003Cb\u003E2020er Jahre:\u003C\u002Fb\u003E"},{bullets:["Spring Boot als Standard","Microservices-Architekturen","Container (Docker, Kubernetes)","REST APIs statt JSPs"]},{content:"\u003Cb\u003EUnd plötzlich neue Buzzwords:\u003C\u002Fb\u003E"},{bullets:[e,"Ports & Adapters","Clean Architecture",f]},{heading:"Die Verunsicherung",content:"Als ich diese neuen Begriffe hörte, dachte ich zunächst:\u003Cbr\u003E\u003Cbr\u003E\"Ist unsere alte Architektur veraltet? Haben wir es falsch gemacht? Müssen wir alles neu lernen?\"\u003Cbr\u003E\u003Cbr\u003EKonferenzen voller Talks über \"moderne Architektur\". Bücher über Clean Code und Domain-Driven Design. YouTube-Videos über Hexagonal Architecture.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EDie implizite Botschaft:\u003C\u002Fb\u003E \"Das Alte ist schlecht, das Neue ist besser.\""},{heading:"Die Lösung: Der Blick hinter die Buzzwords",content:a},{heading:"Der Aha-Moment",content:"Letzte Woche saß ich mit einem Kollegen zusammen und wir diskutierten über Hexagonal Architecture. Er zeigte mir ein Diagramm:\n\n```\nREST Controller (Adapter)\n        ↓\nApplication Service (Port)\n        ↓\nDomain Logic (Core)\n        ↓\nRepository Interface (Port)\n        ↓\nRepository Impl (Adapter)\n```\n\nIch schaute es an – und mir fiel die Kinnlade runter.\n\n\u003Cb\u003EDas ist exakt das, was wir vor 15 Jahren auch gemacht haben!\u003C\u002Fb\u003E"},{heading:"Der Vergleich: Damals vs. Heute",columns:{damals:"Damals (2010)",heute:"Heute (2025)",category:"Das Prinzip"},comparison:[{category:"Eingangs-Schnittstelle zur Außenwelt",damals:"Struts Action",heute:"REST Controller (Adapter)"},{category:"Business-Logik-Abstraktion",damals:"Service Interface + Impl",heute:"Application Service (Port)"},{category:"Konkrete Business-Operationen",damals:"Service-Methoden",heute:"Use Cases"},{category:"Persistenz-Abstraktion",damals:"DAO Interface",heute:"Repository Port"},{category:"Konkrete Datenbankanbindung",damals:"iBatis Mapper",heute:"Repository Adapter"}]},{content:"\u003Cb\u003EEs ist das Gleiche. Nur die Namen haben sich geändert.\u003C\u002Fb\u003E"},{heading:"Was wirklich neu ist (und was nicht)",content:"\u003Cb\u003EWirklich neu:\u003C\u002Fb\u003E"},{bullets:["✅ Syntax: @RestController statt XML-Konfiguration","✅ Tools: Spring Boot vs. Struts + XML","✅ Deployment: Container vs. WAR-Files","✅ Terminologie: \"Ports & Adapters\" vs. \"DAOs\""]},{content:"\u003Cb\u003ENICHT neu:\u003C\u002Fb\u003E"},{bullets:["❌ Separation of Concerns","❌ Dependency Inversion","❌ Abstraktion über Interfaces","❌ Testability durch Mocking","❌ Lose Kopplung zwischen Schichten"]},{content:"\u003Cb\u003EDie Prinzipien sind identisch. Nur die Verpackung ist moderner.\u003C\u002Fb\u003E"},{heading:"1. Separation of Concerns funktioniert seit Jahrzehnten",content:b,codeSnippets:["\u002F\u002F Struts Action (2010)\npublic class UserAction extends Action {\n    private UserService userService; \u002F\u002F injected\n    public ActionForward execute(...) {\n        User user = userService.findById(id);\n        request.setAttribute(\"user\", user);\n        return mapping.findForward(\"success\");\n    }\n}"],contentAfterCode:a},{content:c,codeSnippets:["\u002F\u002F REST Controller (2025)\n@RestController\npublic class UserController {\n    private final UserService userService;\n    @GetMapping(\"\u002Fusers\u002F{id}\")\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id);\n    }\n}"],contentAfterCode:"\u003Cb\u003EUnterschied:\u003C\u002Fb\u003E Syntax. Prinzip: Das Gleiche – Controller delegiert an Service."},{heading:"2. Dependency Inversion war schon immer klug",content:b,codeSnippets:["\u002F\u002F Service Layer (2010)\npublic class UserServiceImpl implements UserService {\n    private UserDAO userDAO; \u002F\u002F Interface!\n    public User findById(Long id) {\n        return userDAO.findById(id);\n    }\n}"],contentAfterCode:a},{content:c,codeSnippets:["\u002F\u002F Application Service (2025)\n@Service\npublic class UserService {\n    private final UserRepository userRepository; \u002F\u002F Interface!\n    public User findById(Long id) {\n        return userRepository.findById(id);\n    }\n}"],contentAfterCode:"\u003Cb\u003EUnterschied:\u003C\u002Fb\u003E Annotation. \u003Cb\u003EPrinzip:\u003C\u002Fb\u003E Das Gleiche – abhängig von Abstraktion, nicht Implementierung."},{heading:"3. Testability durch Interfaces war immer wichtig",content:b,codeSnippets:["\u002F\u002F Unit Test (2010)\npublic class UserServiceTest {\n    @Test\n    public void testFindById() {\n        UserDAO mockDAO = mock(UserDAO.class);\n        when(mockDAO.findById(1L)).thenReturn(testUser);\n        UserService service = new UserServiceImpl(mockDAO);\n        User result = service.findById(1L);\n        assertEquals(\"John\", result.getName());\n    }\n}"],contentAfterCode:a},{content:c,codeSnippets:["\u002F\u002F Unit Test (2025)\n@Test\npublic void testFindById() {\n    UserRepository mockRepo = mock(UserRepository.class);\n    when(mockRepo.findById(1L)).thenReturn(Optional.of(testUser));\n    UserService service = new UserService(mockRepo);\n    User result = service.findById(1L);\n    assertEquals(\"John\", result.getName());\n}"],contentAfterCode:"\u003Cb\u003EUnterschied:\u003C\u002Fb\u003E Minimal. \u003Cb\u003EPrinzip:\u003C\u002Fb\u003E Exakt das Gleiche – Mock die Abhängigkeit, teste die Logik."},{heading:"Die Erkenntnis",content:"\u003Cb\u003EWir haben keine schlechte Architektur gebaut.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003EWir haben \u003Cb\u003Esolide Prinzipien\u003C\u002Fb\u003E angewendet:"},{bullets:["Loose Coupling","Dependency Inversion","Separation of Concerns","Testability"]},{content:"Die Industrie hat diese Prinzipien nur \u003Cb\u003Eneu verpackt und umbenannt:\u003C\u002Fb\u003E"},{bullets:["\"DAO\" → \"Repository\"","\"Service Layer\" → \"Application Service\" \u002F \"Use Case\"","\"Layered Architecture\" → \"Hexagonal Architecture\" \u002F \"Clean Architecture\""]},{content:"\u003Cb\u003EDie Prinzipien waren immer da. Wir haben nur neue Worte dafür gefunden.\u003C\u002Fb\u003E"},{heading:"2. Prinzipien wichtiger als Namen",content:"\u003Cb\u003EDer Fehler:\u003C\u002Fb\u003E Stunden damit verbringen, zu diskutieren: \"Ist das jetzt ein Port oder ein Adapter?\"\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EDie Realität:\u003C\u002Fb\u003E Die Frage sollte sein: \"Ist diese Komponente testbar? Ist sie entkoppelt? Ist sie wartbar?\"\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003ENamen sind Kommunikationsmittel, keine Dogmen.\u003C\u002Fb\u003E"},{heading:"3. Hype vs. Substanz unterscheiden",content:"\u003Cb\u003EFrameworks kommen und gehen:\u003C\u002Fb\u003E"},{bullets:["Struts (tot)","JSF (fast tot)","Spring MVC (Standard, aber wird weniger)","React (aktuell Hype)","Next.js (noch neuerer Hype)"]},{content:"Prinzipien bleiben:"},{bullets:["SOLID (seit 2000, immer noch gültig)","Separation of Concerns (seit 1970er)","Dependency Inversion (seit immer)","Testability (seit immer)"]},{content:"\u003Cb\u003EInvestiere in Prinzipien, nicht in Hype.\u003C\u002Fb\u003E"},{heading:"4. Alte Code-Basen sind nicht automatisch schlecht",content:"\u003Cb\u003EDer Fehler:\u003C\u002Fb\u003E \"Dieser Code ist 10 Jahre alt, der muss schlecht sein!\"\u003Cbr\u003E\u003Cbr\u003E"},{content:"\u003Cb\u003EDie Realität:\u003C\u002Fb\u003E Wenn der Code sauber strukturiert ist, testbar ist und funktioniert – dann ist er \u003Cb\u003Egut\u003C\u002Fb\u003E, egal wie alt.\u003Cbr\u003E\u003Cbr\u003E"},{content:"\u003Cb\u003EAlter ≠ Qualität. Struktur = Qualität.\u003C\u002Fb\u003E"},{heading:"Learnings: Was ich wirklich mitgenommen habe"},{heading:"1. Frameworks sind Werkzeuge, Prinzipien sind Fundamente",content:"\u003Cb\u003EAls Junior (vor 15 Jahren):\u003C\u002Fb\u003E Ich dachte: \"Struts ist DIE Art, Web-Anwendungen zu bauen.\"\u003Cbr\u003E\u003Cbr\u003E"},{content:"\u003Cb\u003EAls Senior (heute):\u003C\u002Fb\u003E Ich weiß: \"Struts war EIN Werkzeug, das mir half, gute Prinzipien anzuwenden.\"\u003Cbr\u003E\u003Cbr\u003E"},{content:"\u003Cb\u003EDie Lektion:\u003C\u002Fb\u003E Wenn du die Prinzipien verstehst (Separation, Decoupling, Testability), kannst du \u003Cb\u003Ejedes Framework lernen.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003EWenn du nur Frameworks auswendig lernst, bist du verloren, sobald ein neues kommt."},{heading:"2. \"Modern\" ist relativ",content:"\u003Cb\u003EHeute modern:\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E"},{bullets:[e,f,"Microservices","Serverless"]},{content:"\u003Cb\u003EIn 10 Jahren:\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E"},{bullets:["Werden neue Buzzwords existieren","Werden heutige \"moderne\" Frameworks Legacy sein","Werden die gleichen Prinzipien immer noch gelten"]},{content:"\u003Cb\u003EDie Lektion:\u003C\u002Fb\u003E Jage nicht Trends. Verstehe Prinzipien."},{heading:"3. Erfahrung bedeutet Muster erkennen",content:"\u003Cb\u003EDas ist der Unterschied zwischen Junior und Senior:\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EJunior:\u003C\u002Fb\u003E \"Hexagonal Architecture ist neu, ich muss es lernen!\"\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003ESenior:\u003C\u002Fb\u003E \"Hexagonal Architecture? Das ist wie DAO-Pattern mit neuem Namen.\"\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EDie Lektion:\u003C\u002Fb\u003E Mit Erfahrung siehst du, dass sich vieles wiederholt – nur mit anderen Worten.\u003Cbr\u003E\u003Cbr\u003E"},{heading:"4. Gute Architektur ist zeitlos",content:"\u003Cb\u003EKriterien für gute Architektur (2010):\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E"},{bullets:[g,h,i,j]},{content:"\u003Cb\u003EKriterien für gute Architektur (2025):\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E"},{bullets:[g,h,i,j]},{content:"\u003Cb\u003EDie Lektion:\u003C\u002Fb\u003E Diese Kriterien haben sich \u003Cb\u003Enicht geändert.\u003C\u002Fb\u003E Und sie werden sich auch in 10 Jahren nicht ändern.\u003Cbr\u003E\u003Cbr\u003E"},{heading:"5. Bescheidenheit gegenüber der Vergangenheit",content:"\u003Cb\u003EFrüher dachte ich:\u003C\u002Fb\u003E \"Die alten Entwickler haben es nicht verstanden. Wir machen es heute besser.\"\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EHeute weiß ich:\u003C\u002Fb\u003E \"Die alten Entwickler haben die gleichen Prinzipien verstanden. Sie hatten nur andere Tools.\"\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EDie Lektion:\u003C\u002Fb\u003E Respekt vor der Arbeit früherer Entwickler. Sie haben oft \u003Cb\u003Esehr gut\u003C\u002Fb\u003E gearbeitet – nur mit anderen Mitteln.\u003Cbr\u003E\u003Cbr\u003E"},{heading:"Der Blick nach vorne"},{heading:"Was bedeutet das für meine Arbeit?",content:"Diese Erkenntnis hat meine Perspektive fundamental verändert:\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EIch frage nicht mehr:\u003C\u002Fb\u003E \"Ist dieses Framework modern?\"\u003Cbr\u003E\u003Cb\u003EIch frage:\u003C\u002Fb\u003E \"Hilft mir dieses Framework, gute Prinzipien umzusetzen?\"\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EIch frage nicht mehr:\u003C\u002Fb\u003E \"Müssen wir zu Hexagonal Architecture migrieren?\"\u003Cbr\u003E\u003Cb\u003EIch frage:\u003C\u002Fb\u003E \"Ist unsere Architektur testbar, wartbar und entkoppelt?\"\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EIch falle nicht mehr auf Hype rein.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cb\u003EIch fokussiere mich auf zeitlose Prinzipien.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E"},{heading:"Was empfehle ich anderen?"},{content:"\u003Cb\u003EFür Junior-Entwickler:\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E"},{bullets:["❌ \u003Cb\u003ENicht:\u003C\u002Fb\u003E \"Lerne Hexagonal Architecture auswendig\"","✅ \u003Cb\u003EBesser:\u003C\u002Fb\u003E \"Verstehe, WARUM wir Schichten trennen und Abhängigkeiten umkehren\"","❌ \u003Cb\u003ENicht:\u003C\u002Fb\u003E \"Spring Boot ist DIE Lösung\"","✅ \u003Cb\u003EBesser:\u003C\u002Fb\u003E \"Spring Boot ist EIN Werkzeug, das Prinzipien umsetzt\""]},{content:"\u003Cb\u003EWenn du die Prinzipien verstehst:\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E"},{bullets:["Kannst du jedes Framework lernen","Erkennst du gute vs. schlechte Architektur","Bist du nicht abhängig von Trends"]},{content:"\u003Cb\u003EFür Senior-Entwickler:\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E"},{bullets:["❌ \u003Cb\u003ENicht:\u003C\u002Fb\u003E \"Unsere alte Architektur ist veraltet\"","✅ \u003Cb\u003EBesser:\u003C\u002Fb\u003E \"Unsere Architektur folgt soliden Prinzipien – das zählt\"","❌ \u003Cb\u003ENicht:\u003C\u002Fb\u003E \"Wir müssen auf Hexagonal refactoren\"","✅ \u003Cb\u003EBesser:\u003C\u002Fb\u003E \"Haben wir ein Problem, das Hexagonal lösen würde?\""]},{content:"\u003Cb\u003ERefactore nur mit klarem Grund, nicht wegen Buzzwords.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E"},{heading:"In 15 Jahren"},{content:"\u003Cb\u003EWas wird anders sein:\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E"},{bullets:["Spring Boot wird vielleicht Legacy sein","Neue Frameworks werden existieren","Neue Buzzwords werden Konferenzen füllen","Neue Annotations werden erfunden"]},{content:"\u003Cb\u003EWas gleich bleiben wird:\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E"},{bullets:["Separation of Concerns wird wichtig sein","Testability wird zählen","Loose Coupling wird gelten","Dependency Inversion wird funktionieren"]},{content:"\u003Cb\u003EDenn wie ein kluger Entwickler mal sagte:\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E\"Technology keeps changing, but the principles barely move.\"\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EOder noch prägnanter:\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E\"Nothing's really new. It just gets a new name, a new annotation, and a new conference talk.\""},{heading:"Fazit: Prinzipien über Frameworks"},{content:"Nach 15 Jahren in der Softwareentwicklung ist das meine wichtigste Erkenntnis:\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EFrameworks sind temporär. Prinzipien sind ewig.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003EStruts ist tot. iBatis ist umbenannt. XML-Konfiguration ist out.\u003Cbr\u003E\u003Cbr\u003EAber Separation of Concerns? Dependency Inversion? Testability?\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EDie werden noch in 50 Jahren gelten.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003EDas ist nicht Nostalgie. Das ist nicht Widerstand gegen Neues.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EEs ist Weisheit aus Erfahrung:\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003EDie besten Entwickler sind nicht die, die jeden neuen Trend mitgehen.\u003Cbr\u003EDie besten Entwickler sind die, die verstehen, \u003Cb\u003Ewas unter der Oberfläche wirklich zählt.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003EUnd das sind nicht Frameworks.\u003Cbr\u003E\u003Cb\u003EDas sind Prinzipien.\u003C\u002Fb\u003E"}]}}],fetch:{},mutations:void 0}}("","\u003Cb\u003EDamals:\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E","\u003Cb\u003EHeute:\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003E","Hexagonal Architecture in der Praxis: Warum sich weniger ändert, als man denkt","Hexagonal Architecture","Domain-Driven Design","Testbar","Wartbar","Erweiterbar","Entkoppelt")));