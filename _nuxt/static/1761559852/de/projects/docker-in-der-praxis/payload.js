__NUXT_JSONP__("/de/projects/docker-in-der-praxis", (function(a){return {data:[{project:{slug:"docker-in-der-praxis",title:a,layout:"textlayout",sections:[{heading:a,content:"Nach vielen Jahren in der Softwareentwicklung habe ich gelernt: Die interessantesten Projekte sind nicht die, wo alles perfekt und modern ist. Es sind die, wo man mit der Realität umgehen muss – mit gewachsenen Systemen, Legacy-Code und der Herausforderung, Altes und Neues miteinander zu verbinden.\n\nGenau in so einer Welt arbeite ich seit Jahren. Und genau hier zeigt Docker seine wahre Stärke."},{heading:"Der Ausgangspunkt: Eine gewachsene Infrastruktur",content:"Vor einigen Jahren sah unsere Entwicklungslandschaft noch klassisch aus:"},{bullets:["\u003Cb\u003EJenkins\u003C\u002Fb\u003E als Build- und Deployment-Tool","Manuelle Setups für Entwicklungsumgebungen","Oracle-Datenbanken, die auf jedem Entwicklerrechner anders konfiguriert waren","Deployments, die funktionierten – aber oft nur nach mehreren Versuchen"]},{content:"Das war nicht schlecht. Es hat funktioniert. Aber es war aufwändig."},{heading:"Das erste Docker-Experiment: Oracle DB",content:"Unser erster Berührungspunkt mit Docker war pragmatisch: \u003Cb\u003EOracle-Datenbank für die Entwicklung.\u003C\u002Fb\u003E\n\nVorher bedeutete Oracle-Setup:"},{bullets:["2-3 Stunden Installation und Konfiguration","Unterschiedliche Versionen auf verschiedenen Rechnern","\"Bei mir läuft's\" – beim Kollegen nicht"]},{content:"Mit Docker:\n\n```\ndocker run oracle-db\n```\n\n10 Minuten. Gleiche Version überall. Reproduzierbar.\n\n\u003Cb\u003EDas war der Moment, wo ich verstanden habe: Docker löst nicht primär technische Probleme. Es löst menschliche Probleme.\u003C\u002Fb\u003E\n\nNeue Entwickler waren produktiv, statt frustriert. Seniors verloren keine Zeit mehr mit Setup-Support. Das allein rechtfertigte den Aufwand."},{heading:"Der Wendepunkt: Azure CI\u002FCD und eine komplexe E-Commerce-Architektur",content:"Dann kam der große Schritt: Migration zu Azure DevOps mit einer vollständig containerbasierten CI\u002FCD-Pipeline – und gleichzeitig die Integration einer etablierten E-Commerce-Plattform durch einen Entwicklungspartner."},{heading:"Die Herausforderung: Hybrid-Architektur",content:"Große E-Commerce-Plattformen sind über Jahre gewachsen. Das bedeutet auch: \u003Cb\u003ELegacy ist Realität.\u003C\u002Fb\u003E\n\nUnsere Architektur heute:"},{bullets:["\u003Cb\u003EEine etablierte Commerce-Plattform\u003C\u002Fb\u003E – bewährt, aber mit älteren Technologien","\u003Cb\u003EPWA Storefront\u003C\u002Fb\u003E – moderne Angular-basierte Progressive Web App","\u003Cb\u003EModerne Microservices\u003C\u002Fb\u003E – Angebots-Service, Händler-Service, Produkt-Service","\u003Cb\u003ESPA-basiertes Admin-Portal\u003C\u002Fb\u003E – komplett modern entwickelt"]},{content:"Das Interessante: Die PWA sieht modern aus, läuft auf modernem Stack – aber arbeitet im Hintergrund teilweise noch mit der Legacy-Plattform zusammen. Bestimmte Funktionen wie Checkout oder komplexe Account-Verwaltung werden an das etablierte System delegiert.\n\n\u003Cb\u003EDas ist Enterprise-Realität:\u003C\u002Fb\u003E Nicht alles kann über Nacht neu geschrieben werden. Man muss mit dem arbeiten, was da ist."},{heading:"Was Docker hier konkret löst",content:""},{heading:"1. Service-Isolation trotz heterogener Technologien",content:"Wir haben Services auf unterschiedlichen Tech-Stacks:"},{bullets:["Legacy-Plattform (Java-basiert, ältere Frameworks)","Moderne Backend-Services (aktuelle Java-Versionen, moderne Architekturen)","Frontend (Angular PWA, Node.js-basiert)"]},{content:"Ohne Docker müsste jeder Entwickler alle diese Umgebungen lokal installieren und pflegen. Mit Docker läuft jeder Service in seinem eigenen Container mit genau den Dependencies, die er braucht.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EErgebnis:\u003C\u002Fb\u003E Ein Entwickler kann am Frontend arbeiten, ohne Java installiert zu haben. Ein Backend-Entwickler kann verschiedene Service-Versionen parallel testen."},{heading:"2. CI\u002FCD-Pipeline wird konsistent und schnell",content:"Der Wechsel von Jenkins zu Azure DevOps mit Docker brachte messbare Verbesserungen."},{content:"\u003Cb\u003EVorher (Jenkins):\u003C\u002Fb\u003E"},{bullets:["Build-Zeit: 15-25 Minuten (je nach Service)","Deployment: manuell, fehleranfällig","Unterschiede zwischen Build-Umgebung und Production"]},{content:"\u003Cb\u003EJetzt (Azure + Docker + Helm):\u003C\u002Fb\u003E"},{bullets:["Build-Zeit: 8-12 Minuten für die meisten Services","Deployment: automatisiert via Helm Charts","Identische Container von Dev bis Production"]},{content:"Die modernen Services – Angebots-Service, Händler-Service, Produkt-Service – laufen besonders gut. Sie wurden von Anfang an für Container designed. Kurze Build-Zeiten, klare Dependencies, saubere Isolation."},{heading:"3. Helm Charts: Deployment wird deklarativ",content:"Helm Charts haben das Deployment revolutioniert. Statt manueller Konfiguration beschreibt eine YAML-Datei das gesamte Deployment:\n\n```yaml\nservice: offer-service\nversion: 1.2.3\nreplicas: 3\nresources: ...\n```\n\nEin Deployment über mehrere Umgebungen (Dev, Staging, Production) wird dadurch:"},{bullets:["Nachvollziehbar (alles ist in Git versioniert)","Wiederholbar (gleicher Befehl, gleiches Ergebnis)","Sicher (Rollback mit einem Befehl möglich)"]},{heading:"4. Die Legacy-Bridge: Alt und Neu koexistieren",content:"Hier zeigt sich die wahre Stärke von Docker: \u003Cb\u003EEs ermöglicht Koexistenz.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003EDie Legacy-Plattform läuft in ihren Containern mit ihren spezifischen Anforderungen. Die modernen Services laufen in ihren Containern mit modernen Stacks. Die PWA kommuniziert mit beiden – transparent durch Docker-Networking.\n\nWir müssen die alte Plattform nicht neu schreiben. Wir können sie schrittweise durch moderne Services ersetzen – Service für Service. Docker macht diesen evolutionären Ansatz praktikabel."},{heading:"Was man dabei lernen muss (die kritischen Punkte)",content:"Nach Jahren mit Docker in dieser komplexen Umgebung habe ich auch gelernt: \u003Cb\u003EEs ist kein Allheilmittel.\u003C\u002Fb\u003E"},{heading:"1. Performance-Unterschiede sind real",content:"Die modernen Services bauen schnell und laufen performant. Aber manche ältere Services oder Komponenten sind langsamer.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EWarum?\u003C\u002Fb\u003E"},{bullets:["Große Images (manchmal 1-2 GB)","Komplexe Build-Prozesse","Viele Dependencies"]},{content:"\u003Cb\u003ELektion:\u003C\u002Fb\u003E Docker macht langsame Software nicht schnell. Es macht sie nur reproduzierbar langsam."},{heading:"2. Debugging wird komplexer",content:"Wenn ein Service im Container nicht funktioniert, ist Debugging schwieriger:"},{bullets:["Logs sind über mehrere Container verteilt","Netzwerk-Probleme zwischen Containern sind subtil","Der Zugriff auf laufende Container erfordert zusätzliche Schritte"]},{content:"\u003Cb\u003ELösung:\u003C\u002Fb\u003E Gutes Logging und Monitoring sind nicht optional. Sie sind kritisch."},{heading:"3. Image-Management braucht Disziplin",content:"Mit Azure Container Registry und vielen Services haben wir hunderte Images. Ohne klare Versionierung und Cleanup-Strategie wird es schnell unübersichtlich.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003ELearnings:\u003Cb\u003E"},{bullets:["Semantic Versioning konsequent nutzen","Alte Images regelmäßig löschen","Security-Scans automatisieren"]},{heading:"4. Nicht alles gehört in Container",content:"Ich habe auch gelernt: Manche Komponenten laufen besser außerhalb von Containern. Besonders bei I\u002FO-intensiven Operationen oder wenn externe Tools integriert werden müssen.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EDie Frage ist nicht:\u003C\u002Fb\u003E \"Kann ich das dockern?\"\u003Cbr\u003E\u003Cb\u003EDie Frage ist:\u003C\u002Fb\u003E \"Sollte ich das dockern?\""},{heading:"Was ich wirklich gelernt habe",content:"Nach Jahren in dieser Hybrid-Welt zwischen Legacy und modernen Microservices ist meine wichtigste Erkenntnis:\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EDocker ist ein Enabler für schrittweise Transformation.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003EEs erlaubt uns:"},{bullets:["Alte Systeme am Leben zu halten, während wir neue bauen","Verschiedene Technologien parallel zu betreiben","Services unabhängig voneinander zu entwickeln und zu deployen","Teams autonom arbeiten zu lassen"]},{content:"Aber es ersetzt nicht:"},{bullets:["Gute Architektur-Entscheidungen","Klare Dokumentation","Verständnis der eigenen Systeme","Disziplinierte Entwicklungsprozesse"]},{content:"Die Teams, die mit Docker erfolgreich sind, haben verstanden: \u003Cb\u003EDocker ist ein Werkzeug, kein Selbstzweck.\u003C\u002Fb\u003E"},{heading:"Wann macht Docker Sinn?",content:"Nach dieser Erfahrung würde ich Docker empfehlen für:"},{bullets:["✓ Microservices-Architekturen – Jeder Service in seinem Container, klare Grenzen, unabhängige Deployments.","✓ Hybrid-Umgebungen (Legacy + Modern) – Ermöglicht schrittweise Migration ohne Big-Bang-Rewrite.","✓ Teams mit mehreren Entwicklern – Einheitliche Entwicklungsumgebungen sparen enorm viel Zeit.","✓ CI\u002FCD-Pipelines – Build once, run anywhere – vom lokalen Test bis Production.","✓ Cloud-Deployments – Fast alle Cloud-Plattformen unterstützen Container nativ."]},{content:"Aber Vorsicht bei:"},{bullets:["✗ Sehr einfachen Projekten – Eine statische Website braucht keinen Container-Overhead.","✗ Teams ohne Docker-Erfahrung unter Zeitdruck – Die Lernkurve ist real. Lieber Zeit nehmen oder erstmal klassisch arbeiten.","✗ Legacy-Monolithen ohne klare Modularisierung – Einen Monolithen in einen Container zu packen löst keine Architektur-Probleme.","✗ Performance-kritische Anwendungen mit hohem I\u002FO – Der Container-Overhead kann hier spürbar sein."]},{heading:"Der Blick nach vorne",content:"Diese Jahre mit Docker in einer komplexen Enterprise-Umgebung haben meine Perspektive auf Softwareentwicklung geprägt.\u003Cbr\u003E\u003Cbr\u003EIch habe gelernt:\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003ETechnologie muss Probleme lösen, nicht schaffen.\u003C\u002Fb\u003E  \u003Cbr\u003EDocker löst echte Probleme – wenn man es richtig einsetzt.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EPragmatismus schlägt Purismus.\u003C\u002Fb\u003E  \u003Cbr\u003EDie perfekte Architektur auf dem Papier nützt nichts. Die Hybrid-Lösung, die funktioniert, ist besser.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EEvolution schlägt Revolution.\u003C\u002Fb\u003E  \u003Cbr\u003EKomplette Neuentwicklungen sind oft nicht möglich. Aber schrittweiser Ersatz funktioniert.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003ETeams sind wichtiger als Tools.\u003C\u002Fb\u003E  \u003Cbr\u003EDocker ist nur so gut wie das Team, das es einsetzt. Ohne gemeinsames Verständnis, klare Standards und Disziplin wird auch Docker zum Problem."},{heading:"Was das für mich bedeutet",content:"Diese Erfahrung – zwischen Legacy und modernen Microservices, zwischen alten und neuen Technologien – hat mir gezeigt, worum es in der Softwareentwicklung wirklich geht:\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003ENicht die coolste Technologie zu verwenden, sondern die richtige.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003ENicht alles neu zu bauen, sondern \u003Cb\u003Esmart mit dem zu arbeiten, was da ist.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003ENicht Perfektion anzustreben, sondern \u003Cb\u003Ekontinuierliche Verbesserung.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003EDas ist die Denkweise, die ich in zukünftige Projekte mitbringe.\u003Cbr\u003E\u003Cbr\u003EDenn am Ende geht es nicht um Container, Microservices oder CI\u002FCD-Pipelines.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EEs geht darum, Software zu bauen, die echte Probleme löst – pragmatisch, nachhaltig und mit Mehrwert für die Menschen, die damit arbeiten.\u003C\u002Fb\u003E"}]}}],fetch:{},mutations:void 0}}("Docker in der Praxis: Von Legacy zu modernen Microservices")));