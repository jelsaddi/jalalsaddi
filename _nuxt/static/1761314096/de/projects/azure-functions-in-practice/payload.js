__NUXT_JSONP__("/de/projects/azure-functions-in-practice", (function(a,b){return {data:[{project:{slug:"azure-functions-in-practice",title:a,layout:"textlayout",sections:[{heading:a,content:"Nach vielen Jahren in der Softwareentwicklung habe ich gelernt: Die besten technischen Lösungen sind oft die unsichtbaren. Serverless Computing klang für mich lange nach Buzzword und Hype. Bis ich einen konkreten Use Case hatte, bei dem Azure Functions genau das richtige Werkzeug waren.\n\nDies ist die Geschichte, wie wir mit einer einfachen serverless Function ein wiederkehrendes Problem elegant gelöst haben – und was ich dabei über Serverless wirklich gelernt habe."},{heading:"Der Kontext: E-Commerce und das Bildproblem",content:"Wir arbeiten an einem E-Commerce-Marktplatz, der auf Azure deployed ist. Wie in jedem Online-Shop sind Produktbilder zentral für die User Experience. Aber Produktbilder haben ein Problem:\u003Cb\u003E Ein Bild passt nicht überall.\u003C\u002Fb\u003E"},{heading:"Die Realität",bullets:["Homepage-Kacheln brauchen kleine Thumbnails (schnell laden, Übersicht)","Produktlisten brauchen mittlere Bilder (Balance zwischen Qualität und Performance)","Produktdetailseiten brauchen große, hochauflösende Bilder (Zoom, Details)"]},{content:"Unsere Bilder landen zunächst als Originale im \u003Cb\u003EAzure Blob Storage\u003C\u002Fb\u003E – hochgeladen von Händlern, Produktmanagern oder über APIs. \u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EDas Problem:\u003C\u002Fb\u003E Die Originale sind oft 3-5 MB groß. Für Thumbnails völlig überdimensioniert. Für Mobile katastrophal. Für Page Speed ein Desaster."},{heading:"Das Problem: Jedes Bild in drei Größen – automatisch",content:"Die Anforderung war klar: \u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EJedes Produktbild muss in drei Formaten verfügbar sein:\u003C\u002Fb\u003E"},{bullets:["Thumbnail – kleine Vorschau","Medium – Standardansicht in Listen","Large – hochauflösend für Detailseiten"]},{content:"Und zwar:"},{bullets:["✅ Automatisch bei jedem neuen Bild","✅ Bei jeder Änderung an existierenden Bildern","✅ Auch für alle bereits existierenden Bilder (Migration)"]},{heading:"Warum das nicht trivial ist",content:"\u003Cb\u003EOption 1: On-the-fly Resizing beim Abruf\u003C\u002Fb\u003E"},{bullets:["Server muss bei jedem Request das Bild verarbeiten","Performance-Problem bei vielen gleichzeitigen Anfragen","Cache hilft, aber erster Request ist langsam"]},{content:"\u003Cb\u003EOption 2: Manuell vor Upload\u003C\u002Fb\u003E"},{bullets:["Händler müssen 3 Versionen hochladen","Fehleranfällig, inkonsistent","Unmöglich für bereits existierende Tausende von Bildern"]},{content:"\u003Cb\u003EOption 3: Cronjob auf einem Server\u003C\u002Fb\u003E"},{bullets:["Server läuft 24\u002F7, auch wenn nichts zu tun ist","Polling ineffizient","Verzögerung zwischen Upload und Verfügbarkeit"]},{content:"\u003Cb\u003EWas wir brauchten:\u003C\u002Fb\u003E Eine Lösung, die automatisch reagiert, effizient läuft und nicht für Idle-Zeit kostet."},{heading:"Die Lösung: Azure Functions + Blob Storage Trigger",content:"Ein Kollege schlug vor: \u003Cb\u003EAzure Functions mit Blob Storage Trigger.\u003C\u002Fb\u003E"},{heading:"Das Konzept",bullets:["Neues Bild wird in Azure Blob Storage hochgeladen","Blob Storage feuert automatisch einen Event","Azure Function wird getriggert (ohne Polling, ohne Delay)","Python-Skript mit ImageMagick verarbeitet das Bild","Drei Versionen werden zurück in Blob Storage gespeichert"]},{heading:"Die Architektur",content:"Mit Azure Functions:\n\n```\nOriginal-Bild hochladen\n        ↓\nAzure Blob Storage (Input)\n        ↓\n[Blob Trigger feuert automatisch]\n        ↓\nAzure Function (Python + ImageMagick)\n        ↓\nVerarbeitung: Thumbnail, Medium, Large\n        ↓\nAzure Blob Storage (Output)\n        ↓\nDrei Formate verfügbar\n```\n\n\u003Cb\u003EEine einfache, aber effektive Architektur – komplett automatisch und ohne manuelles Eingreifen.\u003C\u002Fb\u003E"},{heading:"Warum Azure Functions?",bullets:["\u003Cb\u003EEvent-driven:\u003C\u002Fb\u003E Kein Polling nötig. Die Function startet automatisch, wenn ein Blob hinzugefügt oder geändert wird.","\u003Cb\u003EServerless:\u003C\u002Fb\u003E Keine VM, die 24\u002F7 läuft. Die Function existiert nur während der Ausführung. Du zahlst nur für die Sekunden, in denen sie läuft.","\u003Cb\u003EAuto-Scaling:\u003C\u002Fb\u003E Kommen 100 Bilder gleichzeitig? Azure startet automatisch mehrere Instanzen parallel.","\u003Cb\u003EManaged Infrastructure:\u003C\u002Fb\u003E Microsoft kümmert sich um Runtime, Updates, Verfügbarkeit. Wir schreiben nur Code."]},{heading:"Die technische Umsetzung",bullets:["\u003Cb\u003EPython Runtime auf Azure Functions:\u003C\u002Fb\u003E Python war die natürliche Wahl – einfach, gute Libraries für Bildverarbeitung, vom Team bekannt.","\u003Cb\u003EImageMagick:\u003C\u002Fb\u003E Open-Source Bildverarbeitungs-Tool. Kann Bilder skalieren, konvertieren, optimieren. Wird über Python aufgerufen.","\u003Cb\u003EBlob Trigger:\u003C\u002Fb\u003E Azure Functions haben native Integration mit Blob Storage. Der Trigger-Code ist minimal – Azure macht den Rest."]},{heading:"Das Corrective Script",content:"Die Function löste neue Uploads. Aber was ist mit den \u003Cb\u003ETausenden bereits existierenden Bildern?\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003EDafür haben wir ein einmaliges Corrective Script geschrieben, das alle Bilder im Storage durchläuft, für jedes die Azure Function aufruft (oder direkt verarbeitet). Einmalige Migration, danach läuft alles automatisch."},{heading:"Was funktioniert: Konkrete Erfolge"},{heading:"1. Automatisierung ist komplett unsichtbar",content:"\u003Cb\u003EDas ist das beste Zeichen:\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003ENiemand denkt mehr darüber nach."},{bullets:["Händler laden Bilder hoch → Sekunden später sind alle drei Formate verfügbar.","Kein manueller Schritt.","Keine Wartezeit.","Kein Support-Ticket."]},{heading:"2. Performance der Website verbessert",content:"Vorher:"},{bullets:["Homepage lud 3-5 MB Bilder, auch wenn nur Thumbnails angezeigt wurden","Langsame Ladezeiten, besonders auf Mobile","Schlechter Page Speed Score"]},{content:"Nachher:"},{bullets:["Thumbnails: ~50 KB statt 3 MB","Medium: ~200 KB","Large: Original-Qualität nur wo nötig"]},{content:"\u003Cb\u003EErgebnis:.\u003C\u002Fb\u003E Messbar schnellere Ladezeiten, bessere User Experience"},{heading:"3. Kosteneffizienz",content:"Azure Functions Pricing ist nutzungsbasiert:"},{bullets:["Du zahlst pro Ausführung und pro Sekunde Laufzeit","Bei moderatem Upload-Volumen (täglich neue Produkte, gelegentliche Updates) sind die Kosten minimal"]},{content:"Im Vergleich zu einer VM, die 24\u002F7 läuft:"},{bullets:[b,"Keine Wartung","Automatisches Scaling ohne Mehrkosten-Planung"]},{heading:"4. Einfache Wartung",content:"Der Code ist simpel. Ein Python-Skript, das ImageMagick aufruft. Keine komplexe Infrastruktur. Änderungen sind schnell deployed."},{heading:"Was man beachten muss: Kritische Punkte",content:"Nach Monaten mit dieser Lösung im Einsatz habe ich auch gelernt: \u003Cb\u003EServerless ist kein Allheilmittel\u003C\u002Fb\u003E"},{heading:"1. Cold Start kann spürbar sein",content:"Wenn die Function längere Zeit nicht gelaufen ist, muss Azure eine neue Instanz starten. Das dauert ein paar Sekunden.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EBei uns:\u003C\u002Fb\u003E Meist kein Problem, weil Bilder nicht in Echtzeit vor den Augen des Users verarbeitet werden. Aber bei interaktiven Use Cases (z.B. User lädt Bild hoch und will es sofort sehen) kann Cold Start nerven.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003ELösung:\u003C\u002Fb\u003E Premium Plan mit \"Always On\" – aber dann zahlst du wieder für Idle-Time."},{heading:"2. Debugging ist schwieriger",content:"Läuft etwas schief, ist Debugging komplizierter als auf einem normalen Server:"},{bullets:["Logs sind in Azure Application Insights verstreut.","Lokales Testen braucht Azure Functions Core Tools.","Fehler sind schwerer nachzuvollziehen."]},{content:"\u003Cb\u003ELektion:\u003C\u002Fb\u003E Gutes Logging von Anfang an einbauen. Nicht nachträglich."},{heading:"3. Vendor Lock-in",content:"Azure Functions sind Azure-spezifisch. Code auf AWS Lambda zu migrieren bedeutet Anpassungen. Nicht unmöglich, aber auch nicht trivial.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EAbwägung:\u003C\u002Fb\u003E Für uns war die Developer Experience und native Azure-Integration wichtiger als Portabilität."},{heading:"4. ImageMagick in Serverless ist... speziell",content:"ImageMagick ist ein externes Tool. In Azure Functions muss es als Dependency mitgepackt werden. Das macht das Deployment-Package größer und langsamer.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EAlternative:\u003C\u002Fb\u003E Managed Services wie Azure Cognitive Services für Bildverarbeitung. Teurer, aber einfacher.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EWir haben bei ImageMagick geblieben:\u003C\u002Fb\u003E Mehr Kontrolle, günstiger, Use Case ist einfach genug."},{heading:"5. Nicht für alles geeignet",content:"Azure Functions sind perfekt für:"},{bullets:["Event-driven Tasks","Kurzlaufende Operationen (\u003C 10 Minuten)","Unvorhersehbare Last"]},{content:"Azure Functions sind NICHT gut für:"},{bullets:["Langläufige Prozesse (\u003E 10 Minuten)","Konstant hohe Last (dann ist eine VM günstiger)","Sehr komplexes State Management"]},{heading:"Learnings: Was ich wirklich mitgenommen habe",content:"Nach dieser Erfahrung mit Serverless habe ich verstanden:"},{heading:"1. Serverless heißt nicht \"kein Server\"",content:"Es heißt: \u003Cb\u003EDu managst den Server nicht mehr.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003EDie Infrastruktur existiert noch. Du siehst sie nur nicht. Das ist Abstraktion, kein Verschwinden."},{heading:"2. Serverless ist Architektur-Entscheidung",content:"Man kann nicht einfach eine Anwendung \"serverless machen\". Serverless funktioniert für \u003Cb\u003Espezifische Use Cases:\u003C\u002Fb\u003E"},{bullets:["Event-driven Workflows","Sporadische Tasks","Auto-Scaling-Bedarf"]},{content:"Aber nicht als Ersatz für alles."},{heading:"3. Der ROI ist real – bei richtigem Einsatz",content:"\u003Cb\u003EFür unseren Use Case:\u003C\u002Fb\u003E"},{bullets:["Keine Wartung einer VM",b,"Automatisches Scaling","Schnelle Entwicklung"]},{content:"Das spart Zeit, Geld und Komplexität."},{content:"\u003Cb\u003EAber:\u003C\u002Fb\u003E Für andere Use Cases wäre eine VM oder Container günstiger und einfacher gewesen."},{heading:"4. Start simple, optimize later",content:"Unsere erste Version war simpel: Python + ImageMagick + Blob Trigger. Fertig.\u003Cbr\u003E\u003Cbr\u003EKeine Micro-Optimierungen. Keine komplexe Architektur. \u003Cb\u003EEs hat funktioniert.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003ESpäter kann man optimieren (Premium Plan, bessere Caching, alternative Libraries). Aber für den Start: \u003Cb\u003ESimple is better.\u003C\u002Fb\u003E"},{heading:"5. Serverless ist Commodity geworden",content:"Vor 5 Jahren war Serverless experimentell. Heute ist es Standard. AWS Lambda, Azure Functions, Google Cloud Functions – alle großen Cloud-Anbieter haben es.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EDas bedeutet:\u003C\u002Fb\u003E Es ist nicht mehr Hype. Es ist ein Werkzeug im Toolbelt. Kein Muss, aber eine valide Option."},{heading:"Wann würde ich Azure Functions empfehlen?",content:"Nach dieser Erfahrung würde ich Azure Functions (oder generell Serverless) empfehlen für:"},{bullets:["\u003Cb\u003E✓ Event-driven Tasks\u003C\u002Fb\u003E – Etwas muss passieren, wenn ein Event eintritt (Blob hochgeladen, Queue-Message, HTTP-Request).","\u003Cb\u003E✓ Sporadische Workloads\u003C\u002Fb\u003E – Nicht 24\u002F7, sondern gelegentlich – Serverless-Kosten unschlagbar.","\u003Cb\u003E✓ Prototyping und MVPs\u003C\u002Fb\u003E – Schnell eine Idee testen, ohne Infrastruktur aufzusetzen.","\u003Cb\u003E✓ Glue Code zwischen Services\u003C\u002Fb\u003E – Kleine Funktionen, die verschiedene Azure-Services verbinden.","\u003Cb\u003E✓ Auto-Scaling-Bedarf\u003C\u002Fb\u003E – Last ist unvorhersehbar, Serverless skaliert automatisch."]},{content:"Aber Vorsicht bei:"},{bullets:["\u003Cb\u003E✗ Langläufigen Prozessen\u003C\u002Fb\u003E – Azure Functions haben Timeouts (Standard: 5 Min, max: 10 Min). Für längere Jobs: Azure Batch, Container, VMs.","\u003Cb\u003E✗ Konstant hoher Last\u003C\u002Fb\u003E – Wenn Function 24\u002F7 läuft, VM günstiger.","\u003Cb\u003E✗ Komplexem State Management\u003C\u002Fb\u003E – Serverless ist stateless. Für komplexe Workflows: Durable Functions.","\u003Cb\u003E✗ Sehr niedrigen Latenz-Anforderungen\u003C\u002Fb\u003E – Cold Start kann problematisch sein."]},{heading:"Der Blick nach vorne",content:"Diese Erfahrung mit Azure Functions hat mir gezeigt:\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003ETechnologie sollte zum Problem passen, nicht umgekehrt.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003EWir hatten ein klares Problem: Bilder automatisch verarbeiten. Azure Functions waren dafür perfekt.\u003Cbr\u003E\u003Cbr\u003EAber ich würde nicht versuchen, alles in Functions zu packen. Manche Probleme brauchen VMs. Manche Container. Manche Serverless.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EDie Kunst liegt darin, das richtige Werkzeug zu wählen.\u003C\u002Fb\u003E\u003Cbr\u003E\u003Cbr\u003EDas ist die Denkweise, die ich aus 15 Jahren Entwicklung mitnehme: Nicht Trends folgen, sondern Probleme lösen. Nicht Hype glauben, sondern Vor- und Nachteile abwägen. Nicht Perfektion anstreben, sondern pragmatische Lösungen bauen, die funktionieren.\u003Cbr\u003E\u003Cbr\u003EDenn am Ende geht es nicht um Serverless, Microservices oder Container.\u003Cbr\u003E\u003Cbr\u003E\u003Cb\u003EEs geht darum, Software zu bauen, die echte Probleme löst – effizient, wartbar und mit Mehrwert für die Menschen, die damit arbeiten.\u003C\u002Fb\u003E"}]}}],fetch:{},mutations:void 0}}("Azure Functions in der Praxis: Automatische Bildverarbeitung im E-Commerce","Keine Idle-Kosten")));